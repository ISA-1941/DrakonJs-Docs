:stem:

== SECTION 10. IMPLEMENTATION OF ASSOCIATIVE ARRAYS IN JAVASCRIPT

=== 10.1. Characterization of basic representations of associative arrays in JavaScript

The last section of the book is devoted to associative arrays, considered as abstract type of data in Section 1. According to various estimates, the use of associative arrays (hash-tables, dictionaries) are estimated as 50-70% in total amount of programming. The attractiveness of associative arrays stems from the fact that the average time complexity for basic operations like insertion, deletion, and searching is estimated as O(1).

In JavaScript, associative arrays can be presented in several ways, depending on the requirements for performance, usability and language features. The basic approach to creating a hash-table is the "manual" method of constructing a hash table based on a fixed-size array:

[source,javascript]
----
function createHashTable(size) { 
var table; 
table = new Array(size).fill(null); 
return {
 table: table, 
size: size }; 
} 
----

In turn, the creation of new hash table elements is done by using the function  `createNode(key, value, next = null)`:

[source,javascript]
----
function createNode(key, value, next = null) {
    console.log('[createNode] Node is created:', {
        key,
        value
    });
    return {
        key: key,
        value: value,
        next: next
    };
}
----


One of the most important hashish problems is the choice of an effective hash-function. Let us recall that hash-functions are the cornerstone of hash-table operations, serving as the mechanism that transforms arbitrary keys into array indices within a fixed-size table (Figure 10.1.). 

image::_images/Fig10.1_Hash.svg[width=800, height=600, align="center"]

Their primary role is to distribute entries uniformly across the available slots, minimizing collisions—where multiple keys map to the same index. A well-designed hash-function ensures efficiency by providing near-constant time complexity for `insertions`, `deletions`, and `lookups`, which is essential for high-performance applications like databases, caches, and symbol tables. Without a reliable hash-function, the hash-table could degrade into a less efficient structure, such as a linked list in the worst case, drastically reducing its speed advantages.

Thus, the choice of hash-function directly impacts the trade-off between speed and memory usage, making it a critical consideration in designing robust hash-tables. Description and implementation in JavaScript of some simple hash functions are presented in the following table:


.Description of some basic hash functions 
[cols="1,2,3", options="header"]
|===
| Hash-Function | Description | JavaScript Implementation  

| Modulo (Division)  
| Maps a key to an index using the remainder of division by table size.  
| `function hash(key, size) { return key % size; }`  

| First Character Code  
| Uses the ASCII code of the first character of a string key.  
| `function hash(key, size) { return key.charCodeAt(0) % size; }`  

| Simple String Sum  
| Sums ASCII values of all characters in the string key.  
| `function hash(key, size) {  
    let sum = 0;  
    for (let i = 0; i < key.length; i++) {  
      sum += key.charCodeAt(i);  
    }  
    return sum % size;  
  }`  

| DJB2 (Improved String Hash)  
| A widely used multiplicative hash with better distribution.  
| `function hash(key, size) {  
    let hash = 5381;  
    for (let i = 0; i < key.length; i++) {  
      hash = (hash * 33) + key.charCodeAt(i);  
    }  
    return Math.abs(hash) % size;  
  }`  
|===

=== 10.2. Hash-table on fixed array

The original associative array, hash table algorithm and implementation of basic functions are presented in DRAKON-diagram (Figure 10.2).

image::_images/Fig10_2_mainHash[]

DRAKON-diagram of the selected hash-function is shown in Figure 10.3.

Hash efficiency is most determined by the selection of a hash-function that converts arbitrary size input data into fixed size output data called `hash`. Selection of the hash function determines: 

- data access speed,

- uniform distribution of elements,

- conflict tolerance,

- easy to implement.

The following table gives the most commonly used hash functions:

.Hash Function Comparison
[width="100%",cols="1,2,2",options="header"]
|===
| Function | Advantages | Disadvantages

| **Modular Function**  
`index = key % size`

| * Simple to implement  
* Extremely fast computation  
* Minimal memory overhead

| * Poor distribution for patterned keys  
* High collision rate for sequential data  
* Unsuitable for non-integer keys

| **Multiplicative String Hash**  
`hash = Math.imul(hash,32) - hash + charCode`

| * Good for string keys  
* Better spread than modular  
* Customizable base (e.g., 31, 33)

| * Risk of integer overflow  
* Slower than modular approach  
* Depends on character distribution

| **SHA-256 Scaled Hash**  
`index = size * (sha256Int / 2²⁵⁶)`

| * Excellent key distribution  
* Cryptographically secure  
* Minimal collision probability

| * Computationally expensive  
* Overkill for small datasets  
* Requires external library
|===

_Notes:_
1. The SHA-256 implementation requires conversion from hex string to integer:  
   `sha256Int = parseInt(CryptoJS.SHA256(key).toString(), 16)`
2. The scaling formula should be:  
   `Math.floor(size * (sha256Int / 2**256))` to properly utilize full hash range
3. Multiplicative hash example complete implementation:

The hash efficiency analysis is usually performed based on the calculation of the load factor ( λ ), defined as the ratio of the number of elements stored in the hash table to its total size (number of baskets):

The hash efficiency analysis is usually performed by calculating a load factor ( λ ), defined as the ratio of the number of elements stored in the hash table to the overall size of the table, that is, the number of baskets. The load factor of a hash-table is calculated using the formula:

[math]
++++
\( \alpha \) = n/m
++++

where:
\( \alpha \) is the load factor,
\( n \) is the number of stored elements,
\( m \) is the total number of buckets in the hash table.

The selection of a hash-function and the number of baskets is crucial for reducing the fill ratio of a hash table, with the ultimate goal of eliminating collisions within each basket. Determining the optimal load factor involves a trade-off between memory usage and data retrieval speed; a load factor of approximately 0.75 is often cited. To illustrate, a hash-table is created for 16 "key"-"value" entries using the SHA256 hash-function and two table sizes: 16 and 32. The resulting load factor is 0.44 and nearly zero. This example shows that a low load factor alone doesn't prevent collisions when the input data volume is small.

== Hash Table Distribution Results

=== 1. Original Hash Function (hashFunc)

=== Stats (Size: 16) ===
- Total elements: 16
- Collisions: 7
- Load factor: 0.44

Distribution:
3 | 1 | 0 | 1 | 1 | 2 | 1 | 2 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 0

=== Stats (Size: 32) ===
- Total elements: 16
- Collisions: 0
- Load factor: 0.00

Distribution:
1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | ... 


DRAKON-diagrams of the algorithm for searching for an element in a hash table by key and by value are presented in  Fig10_5 and Fig10_6.

image::_images/Fig10_5_hashLookUp.svg[width=75%]

[.text-center]
Figure 10.5. DRAKON-diagram of the algorithm for searching by key

image::_images/Fig10_6_hashLookByValue.svg[width=75%]

[.text-center]
Figure 10.6. DRAKON-diagram of the algorithm for searching by value

DRAKON-diagram of the algorithm for deleting an element of a hash table by value are presented in Fig. 10.7.

image::_images/Fig10_7_hashRemove.svg[width=75%]

[.text-center]
Figure 10.7. DRAKON-diagram of the algorithm for deleting an element of a hash-table by value

=== 10.3 Built-in hash-table

The hashing method presented above is useful for educational purposes, demonstration of hashing principles and deep understanding of algorithms, implementation on fixed arrays. However, in most JavaScript applications the V8 built-in engine hash tables are an effective alternative, and more often a preferred solution. They take away from the programmer routine tasks and use optimizations that are difficult to implement manually. 

An effective alternative to "manual" hash on fixed arrays is the built-in hash technology in a server-side JavaScript - `Node.js` execution environment built on the V8 engine. 

Node.js has an extensive ecosystem of packages available through `npm` (Node Package Manager). For educational purposes this means that you can easily find and use ready-made libraries to work with different hash algorithms (for example, cryptographic hashing).

The associative arrays in the V8 engine are represented by the collections `Map` and `Set`, as well as their simplified versions (`WeakMap`, `WeakSet`). Key features and applications of these collections are presented in the table:

.Key features and applications of basic in-built collections

[cols="1,1,1,1,1", options="header"]
|=======================================================================
| Property             | `Object`                                  | `Map`                                     | `WeakMap`                                 | `WeakSet`
| Keys                 | Strings and Symbols                        | Any data types (primitives and objects)   | Only Objects                              | Only Objects
| Enumerability        | Enumerable (via `for...in`, `Object.keys()`, etc.) | Enumerable in insertion order           | Not enumerable                            | Not enumerable
| Size                 | Needs manual determination                | Easily obtained via `size` property       | No simple way to get the size            | No simple way to get the size
| Performance          | Can be slower with a large number of keys and frequent add/delete operations | Generally better performance, especially with a large number of operations | Performance comparable to `Map` for operations related to existing keys | Performance comparable to `Set` for operations related to existing objects
| Garbage Collection   | Object keys prevent objects from being garbage collected | If an object is no longer used, it can be garbage collected (if there are no other strong references to it) | Keys are "weak" references; if a key object is no longer used, the corresponding entry is garbage collected | Objects are stored weakly; if an object is no longer used, it's removed from the `WeakSet`
| Main Use Cases       | Storing simple data, configuration objects, creating classes and prototypes | Storing data where keys are not strings, need to preserve insertion order, frequent addition/deletion of elements | Storing metadata about objects without preventing their garbage collection (e.g., private properties, caching) | Tracking a set of objects without preventing their garbage collection (e.g., registering event listeners)
|=======================================================================

The built-in Map data structure typically employs a hybrid architecture that combines the advantages of hash tables and ordered structures. Its foundation is a hash table that delivers optimal average-case complexity (O(1)) for fundamental operations including insertion, deletion, and lookup. This efficiency comes from the standard hashing mechanism where keys are converted to hash values that directly map to storage locations.

Unlike basic hash table implementations that provide no ordering guarantees, Maps commonly preserve insertion order through an internal 'data chain' structure. This is typically implemented as an auxiliary linked list that runs through all entries, maintaining their original addition order while still providing hash-based access.

The basic functions of the built-in Map data structure are presented in the following table:

.The basic functions of the built-in Map data structure
[cols="1,3", options="header"]
|===
| Function | Description
| `set(key, value)` | Adds a new key-value pair to the associative array or updates the value for an existing key.
| `get(key)` | Returns the value associated with the specified key. If the key is not found, it returns `undefined` (or a default value depending on the language/implementation).
| `has(key)` | Returns a boolean value (`true` or `false`) indicating whether an element with the specified key exists in the associative array.
| `delete(key)` | Removes the element with the specified key from the associative array. Returns `true` if the element was successfully removed, and `false` if the key was not found.
| `clear()` | Removes all key-value pairs from the associative array, making it empty.
| `size` | Returns an integer representing the number of elements (key-value pairs) in the associative array.
| `keys()` | Returns an iterable object containing all the keys in the associative array, in the order of their insertion.
| `values()` | Returns an iterable object containing all the values in the associative array, in the order of insertion of their corresponding keys.
| `entries()` | Returns an iterable object containing all the key-value pairs in the associative array as `[key, value]` arrays, in the order of their insertion.
| `forEach(callbackFn[, thisArg])` | Executes the provided `callbackFn` once for each key-value pair in the associative array, in the order of insertion. Implicitly passes the current value, key, and the `Map` object itself as arguments to the callback function. Does not have a return value.
|===


As you can see from the table above, there is no indication of which hash function to use. This is due to the fact that in the built-in technology Map hash function is defined automatically depending on the type of keys: 


.Hash Function Selection in JavaScript Map
[cols="1,2,2", options="header"]
|===
| Key Type 
| Hash Function Implementation 
| Implementation Notes

| Number 
| Optimized 64-bit hash (varies by engine) 
| - Fast path for integers 
| - Special handling for NaN

| String 
| SipHash-2-4 (in V8/Chrome) 
| - 128-bit security 
| - Prevents hash flooding attacks

| Object 
| Internal object ID (hidden class pointer) 
| - Reference-based comparison 
| - Unaffected by property changes
|===



https://www.geeksforgeeks.org/introduction-to-map-data-structure/

