//:imagesdir: docs-src/modules/section-8/assets/images

[.text-justify]
:figure-caption!:

== SECTION 8. BINARY TREE ALGORITHMS

=== 8.1 Representation of binary trees
:imagesdir: docs-src/modules/section-8/assets/images/part_1

Four types of imbalanced states exist.
Binary trees as an abstract data type were discussed in the first
section, here we will talk about the computer implementation of this
type of data structures using the visual algorithmic language DRAKON and
the programming language JavaScript. Recall the basic terminology of binary trees (Figure 8.1):

image::{imagesdir}/Fig8_1_Term.jpg[width=75%]

[.text-center]
Figure 8.1. Basic tree terminology

_Root:_ The root of the tree is the only node with no incoming edges. It
is the top node in the tree;

_Node:_ This is the basic element of the tree. Each node has data and
two references that can point to zero or its descendants;Edge: This is
also the fundamental part of the tree and is used to connect the two
node points.

_Path:_ A path is an ordered list of nodes connected by edges.

_Leaf:_ A leaf node is a node that has no descendants.

_Tree height:_ The height of a tree is the number of edges on the
longest path between the root and the leaf.

_Node level:_ Node level is the number of edges on the path from the
root node of this node.

The information structure of the binary tree is organised as follows (Figure 8.2):

image::{imagesdir}/Fig8_2_BST.jpg[width=50%]

[.text-center]
Fig.8.2 Binary tree structure (_info_ - value (key), (N - NULL))

Several types of binary trees are discussed in the training literature, the most important of which is classification based on node values:

- a binary search tree;
- AVL-Tree;
- Red-Black Tree.

=== 8.2 Binary search tree

:imagesdir: docs-src/modules/section-8/assets/images/part_2

==== 8.2.1 Building a binary tree

If the tree is organised in such a way that, for each node, all the node
values of its left subtree are less than this node and all the values of
its right subtree are greater, it is called a binary search tree. A BST
is a recursive data structure because each subtree is also a tree. A BST
has the following tree properties consists of nodes that retain unique values;

- each node has zero, one or two child nodes;

- one of the nodes is referred to as the root node, which is at the top of the tree structure;

- each node has only one parent node, except for the root node which has
no parent node;

- the value of each node is greater than that of its left child but less than that of its right child;

A binary search tree is built according to a certain algorithm. Consider the sequence of integers \{11, 5, 17, 15, 1, 8, 19, 13, 21}, represented as a slice of numbers[]. First the root node \{11} is formed, then in the loop for each node recursively the method
`insert(tree, value)` is called (Fig. 8.3 a), which in turn calls the method `createNode(value)`, which creates a new node (Fig. 8.3 b).

//image::{imagesdir}/Fig8_3a_insert.png[width=75%]
image::{imagesdir}/Fig8_3a_insert.png[width=100%, link="{imagesdir}/Fig8_3a_insert.svg", window="_blank"]

//image::{imagesdir}/Fig8_3b_createNode.jpg[width=50%]
image::{imagesdir}/Fig8_3b_createNode.png[width=75%, link="{imagesdir}/ig8_3b_createNode.svg", window="_blank"]

[.text-center]
Fig.8.3 Binary tree DRAKON-diagrams
a) building a tree by insert(node,value); b) creating a node

The complete process of creating a binary tree is shown in Figure 8.4.
The first number 11 is written to the root of the tree. The second
number 5 is less than the value in the tree root, so it is written to
the left subtree. The next number 17 is greater than the root number, so
it is written to the right subtree. Then the number 15 is greater than
the value at the root of the tree, so it is written to the right
subtree, but the right subtree is already built. The number 15 is
compared to the number 17 at the root of the right subtree. Since the
value to be added is less than the value in the root of the right
subtree, we add the left subtree to this node. The final result is a
binary search tree with three variants: a node 5 is the parent of two
children (1,8), a node 15 has only a left child, and a node 19 has only
a right child. This arrangement of nodes is chosen to demonstrate the
function of removing nodes, which will be discussed later.

//image::{imagesdir}/Fig8_4_treeProcess.jpg[width=75%]
image::{imagesdir}/Fig8_4_treeProcess.jpg[width=125%, link="{imagesdir}/Fig8_4_treeProcess.svg", window="_blank"]

[.text-center]
Figure 8.4. Building a binary tree 

8.2.3 Finding a node based on a set value

Another basic operation is the `findNode(value)` function. This function uses a JavaScript instructions construct, which recursively compares the value of
val with the values of other nodes as it traverses the tree. 
The DRAKON-diagram of the `findNode(node, value)`function is shown in Figure 8.5. 

//image::{imagesdir}/Fig8_5_findNode.png[width=100%]
image::{imagesdir}/Fig8_5_findNode.png[width=100%, link="{imagesdir}/Fig8_5_findNode.svg", window="_blank"]

[.text-center]
Figure 8.5. DRAKON-diagram of Node Finding Algorithm

8.2.3 Deleting a node with a specified value

The next basic operation is to delete a node with the specified  value. The function `removeNode (node,value)` is used recursively. 

Let's analyse in more detail the order in which the nodes are moved in these variants.

_Option a):_ Node (21) has no descendants (Figure 8.6.).

In this case, this node is removed by changing the value of `node = null` in the parent node. Figure 8.6. shows the process of deleting node (21)
and the corresponding DRAKON-diagram fragment

image::{imagesdir}/Fig8_6_del21.png[width=75%]

[.text-center]
Figure 8.6. Deleting a node without childs

_Option b):_ Node (19) has a right-hand descendant (Figure 8.7).

In this case, node (19) is removed from the tree by replacing its
address in the parent node (17) with the address of its only descendant
node (21). Figure 8.7. shows the process of removing node (19) and the corresponding DRAKON-diagram fragment.

image::{imagesdir}/Fig8_7_del19.png[width=75%]

[.text-center]
Figure 8.7. Deleting node (19) with right-hand descendant

_Option c):_ Node (8) has a left-hand child (Figure 8.8.).

In this case, node (8) is removed from the tree by replacing its
address in parent node (5) with the address of its only left child node (6). Figure 8.8. shows the process of removing node (8) and the
corresponding DRAKON-diagram fragment.

image::{imagesdir}/Fig8_8_del8.png[width=75%]

[.text-center]
Figure 8.8. Deleting node (8) with left-hand child

_Variant d):_ Node (5) has two descendants (Figure 8.9.). In this case
the binary search tree is rearranged: node (2) moves to the place of node (5):

image::{imagesdir}/Fig8_9_del5.png[width=75%]

[.text-center]
Figure 8.9. Deleting a node (5) with two childs

DRAKON-diagram of the minimum value search method is shown in Fig8.10.

image::{imagesdir}/Fig8_10_findMin.png[width=75%]

[.text-center]
Figure 8.10. DRAKON-diagram of the minimum value search method

The complete DRAKON-diagram of the removal of nodes from a binary search tree is shown in Figure 8.11.

image::{imagesdir}/Fig8_11_removeNode.svg[width=75%]

[.text-center]
Figure 8.11. DRAKON-diagram of the removal of nodes

8.2.4. Traversing the binary search tree

One of the basic tree operations is to traverse tree nodes. Unlike linear data structures, where elements are traversed in a linear order, tree nodes can be traversed in a variety of ways. 
The traversal, in which each ancestor node is viewed before its descendants, is called a pre-ordered walk or direct-order traversal (_pre-order walk_). There is also an _in-order walk_, where the left subtree is visited from bottom to top, then the root node, then the right subtree. The traversal, in which first descendants are viewed and then ancestors, is called a post-ordered or reverse-order traversal (_post-order walk_). All three cases, including the Dragon diagrams, are shown in the Figure 8.12.

image::{imagesdir}/Fig8_12_PreInPost.jpg[width=100%]

[.text-center]
Figure 8.12. Three Classical Tree Traversals: Pre-, In-, Post-Order

=== 8.3 Self-balancing binary trees (AVL-trees)

:imagesdir: docs-src/modules/section-8/assets/images/part_3

The efficiency of any tree operation depends substantially on the order in which the input data is received. For example, if an incoming sequence of numbers is partially sorted in ascending or descending order, this structure will no longer look like a tree (Figure 8.13).

image::{imagesdir}/Fig8_13.png[width=25%]

[.text-center]
Figure 8.13. Partially sorted input data

In such practically "degenerate" trees, the complexity of the operations is determined by the number of nodes, i.e. it is almost linear - O(n).
The left and right subtrees are unbalanced, which can be estimated by the balance coefficient (kb), which is equal to the difference between the heights of the left and right subtrees. Recall that the height of a tree is defined as the length of the longest branch in a subtree (sum of edges). For an ideal binary search tree (a tree where the number of nodes in the left subtree is equal to the number of nodes in the right subtree), this factor is 0 (Figure 8.14).

//image::{imagesdir}/Fig8_14_treeIdeal.png[width=75%]
image::{imagesdir}/Fig8_14_treeIdeal.png[width=100%, link="{imagesdir}/Fig8_14_treeIdeal.svg", window="_blank"]
                   
[.text-center]
Figure 8.14. An ideal binary tree

In real life, ideal binary trees are almost never achieved; programmers often try to build a tree where the height of the left subtree differs from the height of the right subtree by no more than 1. Such trees are called AVL-trees; for such trees the complexity of operations is defined as O(logn), i.e. the execution time of basic operations (search, remove) is significantly less than for BST-trees.

The algorithms for such trees are based on the process of balancing the tree when a new node is inserted or an existing node is removed. The purpose of balancing is to reconstruct the tree so that the heights of the left and right subtrees do not differ by more than 1. The balancing factor must satisfy the following conditions allowable values kb = -1, 0 and +1;

* The value kb = -1 indicates that the right subtree "outweighs" the
left subtree;
* The value kb= +1 indicates that the left subtree "outweighs" the right
subtree;
* a value of kb = 0 indicates that the tree contains an equal number of
nodes on each side, i.e. the tree is perfectly balanced.

The balancing algorithm in its most general form is presented in the following DRAKON-scheme (Figure 8.15)

//image::_images/Fig8_15_buildingAvlTree.png[width=100%]
image::{imagesdir}/Fig8_15_buildingAvlTree.png[width=100%, link="{imagesdir}/Fig8_15_buildingAvlTree.svg", window="_blank"]

[.text-center]
Figure 8.15. The balancing algorithm in its most general view 

The balancing technique boils down to making circular movements of the nodes in four variants:

* right turn (RR);
* Left turn (LL);
* Right - left turn (RL);
* Left to right turn (LR).

The right-hand turn is performed when the root node has a balance factor kb = +2 and its left-hand child has a balance factor kb = +1 (Figure 8.16):

image::{imagesdir}/Fig8_16_RR_turn.jpg[width=100%]

[.text-center]
Figure 8.16. Right turn

The left-hand turn is performed when the root node has a balanced kb = - 2 and its right-hand descendant has a balanced kb = - 1 (Figure 8.17):

image::{imagesdir}/Fig8_17_LL_turn.jpg[width=75%]

[.text-center]
Figure 8.17. Left turn

A right-left turn is performed when the root node has a balance factor
kb = -2 and its right-hand child has a balance factor kb = +1 (Figure
8.18):

image::{imagesdir}/Fig8_18_RL_turn.jpg[width=75%]

[.text-center]
Figure 8.18. Right-left turn

Left-right rotation is performed when a node has a balance factor of kb = +2 and its left child has a balance factor of kb = -1 (Figure 8.19):

image::{imagesdir}/Fig8_19_LR_turn.jpg[width=75%]

[.text-center]
Figure 8.19. Left-right turn

Consider the balancing process in more detail with an example of tree formation when input data is received in this order: [1, 2, 5, 6, 8, 11, 13, 15, 17, 19, 21]. As shown above, such a tree is unbalanced.

Balance checking are started on the arrival of each new node using the `insertNode(node, value)` function, which determines the position of the new node in the left or right subtree relative to the root node. The choice of the balancing path is determined by the method
`rotateInsert(node, value)`. A DRAKON-diagrams of the algorithms of the above methods is shown in Figure 8.20. 

//image::{imagesdir}/Fig8_20_insertNode.png[width=75%]
image::{imagesdir}/Fig8_20_insertNode.png[width=100%, link="{imagesdir}/Fig8_20_insertNode.svg", window="_blank"]

[.text-center]
Figure 8.20. DRAKON-diagram depicting the method of inserting node

The choice of one of the possible balancing paths (rotations) is determined by the `rotateInsert(node, val)` function (Figure 8.21).

//image::{imagesdir}/Fig8_21_rotateInsert.png[width=75%]
image::{imagesdir}/Fig8_21_rotateInsert.png[width=100%, link="{imagesdir}/Fig8_21_rotateInsert.svg", window="_blank"]

[.text-center]
Figure 8.21. DRAKON-diagram depicting the inserting node method

Depending on the location of the new node relative to the parent node and the balance factor values, the left-hand or right-hand rotation methods are performed (Figure 8.22):

//image::{imagesdir}/Fig8_22_twoRotates.jpg[width=75%]
image::{imagesdir}/Fig8_22_twoRotates.jpg[width=100%, link="{imagesdir}/Fig8_22_twoRotates.svg", window="_blank"]

[.text-center]
Figure 8.22. Node rotation programme codes

Let's look at the tree rebuilding process in detail as a result of using the `rotateInsert(node, val)` method on the example of entering the values of three nodes (5,6,8). After receiving the value of last node (8), a "twig" appears instead of the tree that needs to be balanced. In this case the condition in the `rotateInsert(node, val)` method is met: the balancing factor is 2 and the value of node (8) is more,than the parent node (6) and the `rotateLeft(node)` method is called. The balancing process in this case is shown in Figure 8.23:

[.text-center]
image::{imagesdir}/Fig8_23_exampleLL.jpg[width=75%]

Figure 8.23. Example of Left-Left turn balancing

The process of new nodes arriving and rebuilding the resulting AVL-tree by balancing for the input set [1,2,5,6,8,11,13,15,17,19,21] is shown in Figure 8.24.

image::{imagesdir}/Fig8_24_avlTreeProcess.jpg[width=100%]

[.text-center]
Figure 8.24. Process of building a balanced AVL-tree

DRAKON-diagram of the AVL-trees basic operation `findNode(node, val)is shown in Figure 8.25:

//image::{imagesdir}/Fig8_25_findNode.png[width=75%]
image::{imagesdir}/Fig8_25_findNode.png[width=100%, link="{imagesdir}/Fig8_25_findNode.svg", window="_blank"]

[.text-center]
Figure 8.25. DRAKON-diagram depicting the finding a node method

Another basic operation, deleting a node with a specified value, consists of the following steps. The node is searched from the root down through the branches to the node to be deleted. The following situations may occur (Figure 8.27):

image::{imagesdir}/Fig8_26_varDelNode.jpg[width=75%]

[.text-center]
Figure 8.26. Cases for nodes to be removed

{empty}a) The node to be deleted has two non-empty descendants;

{empty}b) The node to be deleted has no descendants;

{empty}c) The node to be deleted has one descendant (left or right).

As with the other methods, a node with a c value is first recursively identified and then one of the options presented is selected. A DRAKON-diagram of the algorithm for deleting a node with the cases for nodes to be removed value is shown in Figure 8.27.

//image::{imagesdir}/Fig8_27_deleteNode.png[width=75%]
image::{imagesdir}/Fig8_27_deleteNode.png[width=75%, link="{imagesdir}/Fig8_27_deleteNode.svg", window="_blank"]

[.text-center]
Figure 8.27. DRAKON-diagram depicting an algorithm for removing a node
with a specified value

The `main()` program inputs an array of data, searches for a node with a
specified  value, and deletes a node with a specified value (Figure 8.28). 

//image::_images/Fig8_28_mainFunction.svg[width=75%]
image::{imagesdir}/Fig8_28_mainFunction.svg[width=75%, link="{imagesdir}/Fig8_28_mainFunction.svg", window="_blank"]

[.text-center]
Figure 8.28. DRAKON-diagram of the main-function 

=== 8.4 Red-black trees

:imagesdir: docs-src/modules/section-8/assets/images/part_4

==== 8.4.1. Inserting a new node and the balancing process

8.4.1.1. Properties of red-black trees

A red-black tree is a variant of a self-balancing binary search tree in which the nodes are placed according to a certain rule and coloured red or black (Figure 8.29)

image::{imagesdir}/Fig8_29_redblackTree.jpg[width=75%]

[.text-center]
Figure 8.29. Red-Black Tree

The nodes containing data (in this case, integers) are internal. In
addition, red-black trees contain imaginary, "null" nodes associated
with tree leaves (Null - in Figure 8.29). Red-black trees satisfy all
the properties of a binary search tree and must have the following
properties:

{empty}1. Each node is coloured red or black.

{empty}2. The root of the tree is always black.

{empty}3. All leaves are black (Null).

{empty}4. Both descendants of the red node are black, i.e. there cannot
be consecutive red nodes.

{empty}5. All simple paths from the node to the descending leaves
contain the same number of black nodes.

Unlike AVL trees, where balance is achieved by balancing the heights of the left and right subtrees, red-black balance is achieved by the properties mentioned above. Adding or removing a node from the red-black
tree can disrupt the red-black tree properties, and restoring balance is achieved by two operations: repainting the nodes and/or rebuilding the whole tree or its subtrees using specific rotations.The most important of these properties are properties 4 and 5.

Property 4 dictates a critical aspect of red-black trees: both descendants of the red node are black.

Property 5 builds on this by enforcing a uniform "black-height" for all paths from any node to its leaf descendants. Regardless of the specific path taken, the count of black nodes remains constant.

Black height is an important term used for red-black trees. This is the number of black nodes on any single path from node x (not including it) to the leaf. Properties 4 and 5 together ensure that the longest path from the root to a leaf (which alternates between red and black nodes) is at most twice as long as the shortest path (comprised solely of black nodes). This constraint guarantees that the tree remains approximately balanced, maintaining a height of O(log n), where n is the number of nodes.

To perform the above operations at the program level, a red-black tree is first created, for which two user types - `node` and `rbTree` are declared:
Node includes the following fields: `data` - node numeric value,  `color` - node color type bool: `red node` - true; `black node` - false, `left`, `right` and `parent` nodes. In turn `rbTree structure` represents the reference type variable, that store objects containing not the "value" itself but a reference to the memory area where this object is stored (Fig. 8.30).

[cols="a,a", frame=none, grid=none, align=center]
|===
| image::{imagesdir}/Fig8_30a_createNode.png[width=100%]
| image::{imagesdir}/Fig8_30b_createTree.png[width=75%]
|===

[.text-center]
Figure 8.30. DRAKON-diagram of Node and Tree  Description

Next, consider the node positions in the tree as a result of each new
node insertion and determine which properties of the red-black tree are
violated. For the purpose of analysis, we introduce the following notation 
for the Red-Black Tree sub-structure (), which we shall subsequently term a  `nodeImages` or "cluster".

All canonical `nodeImages` configurations representing possible red and black node arrangements are summarized in Table 8.3, which shows how each type of violation is detected and corrected to preserve all red-black properties. The following node designations are introduced in Table 8.3:

x – The newly inserted node (red) causing a potential violation.

P – Parent of x.

G – Grandparent of x (parent of P). Always black before fixup.

U – Uncle of x (sibling of P). Can be null (considered black).

Color notation: R – Red, B – Black.

Rotation: Always performed around a node, relinking its children and parent to maintain binary search tree order.

image::{imagesdir}/Fig8_31_family.jpg[width=75%]

[.text-center]
Figure 8.31. Designation of the degree of "kinship" of RB Tree nodes (cluster) (x, P, G, U, S)  

To describe the process of balancing the red-black tree, let’s name the set of nodes involved in the implementation of balancing _tree-cluster_ and enter a local syntax: **:R or :B** is the color of the node. For example, P:R is the red parent.
*<-  or ->* - the direction of the node position. For example, x<-P - the new node x is located to the left of the parent node P. 

image::{imagesdir}/Fig8_32_describeCluster.png[width=75%, link="{imagesdir}/Fig8_32_describeCluster.svg", window="_blank"]

[.text-center]
Figure 8.32. DRAKON-diagram of the Function `describeCluster(tree, node)`

==== 8.4.1.2. Inserting a new node

In the most general way the red-black tree construction algorithm is presented by the function `rbInsert(tree, key)`(Figure 8.33):

//image::{imagesdir}/Fig8_32_rbInsert.png[width=75%]
image::{imagesdir}/Fig8_33_rbInsert.png[width=75%, link="{imagesdir}/Fig8_33_rbInsert.svg", window="_blank"]

[.text-center]
Figure 8.33. DRAKON-diagram of the function `rbInsert(tree, data)`


When a new red node is inserted into the red-black tree, it is first connected in the same way as in a regular binary search tree — by comparing the key values and attaching the node as the left or right child.
However, this simple act of insertion may cause a local violation of one or more red-black properties, most commonly the “no two consecutive red nodes” rule.
To restore balance, the algorithm analyses the local configuration of nodes — a tree-cluster — formed by the newly added node x, its parent P, grandparent G, and uncle U.
Each possible configuration (or `nodeImage`) corresponds to a typical balancing case, which determines the required sequence of operations: recoloring and/or rotation. The DRAKON-diagram of tree balancing when inserting a new  node is shown in Figure 34.

image::{imagesdir}/Fig8_34_fixInsert.png[width=75%, link="{imagesdir}/Fig8_34_fixInsert.svg", window="_blank"]

[.text-center]
Figure 8.34. DRAKON-diagram of the Tree Balancing function `fixInsert(tree, data)`


:!table-caption:

.Table 8.3 — Red-Black Tree Insertion Balancing Cases
[%autowidth]
|===
| Case | Violation (Red-Red Conflict) | Key Condition | Balancing Strategy (Fix) | Result / Notes

| Case A (Red Uncle)
| Parent (P) and the new node (x) are both red.
| The uncle (U) of node x is red.
|

Recolor:
a. Parent (P) → black.
b. Uncle (U) → black.
c. Grandparent (G) → red.

Recurse: Treat the grandparent (G) as the new potential violation point (x) and continue the fix-up procedure upwards.
| The conflict propagates upward. If G becomes the root and is red, it will be repainted black in the final step of the algorithm.

| Case B1 (LL)
| Parent (P) and the new node (x) are both red.
| The uncle (U) is black, and x is the left child of its left child parent (P). (LL configuration)
|

Recolor: P → black, G → red.

Rotate: Perform a right rotation around the grandparent (G).
| The violation is resolved locally. The former parent (P) becomes the new root of this subtree.

| Case B2 (RR)
| Parent (P) and the new node (x) are both red.
| The uncle (U) is black, and x is the right child of its right child parent (P). (RR configuration)
|

Recolor: P → black, G → red.

Rotate: Perform a left rotation around the grandparent (G).
| The violation is resolved locally. The former parent (P) becomes the new root of this subtree.

| Case B3 (LR)
| Parent (P) and the new node (x) are both red.
| The uncle (U) is black. x is the right child of its left child parent (P). (LR configuration)
|

First Rotation: Perform a left rotation around the parent (P). This transforms the configuration into LL (Case B1).

Second Rotation & Recolor: Now, with x and G in an LL relationship relative to the new subtree root, apply the Case B1 fix:
a. Recolor the new local root (x) → black, G → red.
b. Perform a right rotation around the grandparent (G).
| The double rotation restructures the tree to balance it. The new node (x) becomes the root of this subtree.

| Case B4 (RL)
| Parent (P) and the new node (x) are both red.
| The uncle (U) is black. x is the left child of its right child parent (P). (RL configuration)
|

First Rotation: Perform a right rotation around the parent (P). This transforms the configuration into RR (Case B2).

Second Rotation & Recolor: Now, with x and G in an RR relationship relative to the new subtree root, apply the Case B2 fix:
a. Recolor the new local root (x) → black, G → red.
b. Perform a left rotation around the grandparent (G).
| The double rotation restructures the tree to balance it. The new node (x) becomes the root of this subtree.
|===


.Table 8.4 — Mapping of CLRS Cases to Video Variants
|===
| CLRS Case | Table Variant | Video Code | Meaning

| Case 1
| Red Uncle
| A
| Recolor

| Case 2
| LR
| B3
| Inner rotation

| Case 2
| RL
| B4
| Inner rotation

| Case 3
| LL
| B1
| Outer rotation

| Case 3
| RR
| B2
| Outer rotation
|===


The DRAKON-diagram of the red-black tree balancing algorithm when entering a new node is shown in Figure 8.33,8.34.

//image::{imagesdir}/Fig8_34_fixRedRed.png[width=100%]
image::{imagesdir}/Fig8_33_fixRedRed.png[width=100%, link="{imagesdir}/Fig8_33_fixRedRed.svg", window="_blank"]

[.text-center]
Figure 8.33. Red-Black Tree Balancing Algorithm DRAKON-diagram 


//image::{imagesdir}/Fig8_35_diagr_figs.png[width=75%]
image::{imagesdir}/Fig8_34_diagr_figs.png[width=100%, link="{imagesdir}/Fig8_34_diagr_figs.svg", window="_blank"]

[.text-center]
Figure 8.34. Illustration of Red-Black Tree Balancing Algorithms

The DRAKON-diagram of the node rotation algorithms to the red and black tree cluster is shown in Figure 8.35a,b.

//image::{imagesdir}/Fig8_36a_rotateLeft.png[width=75%]
image::{imagesdir}/Fig8_35a_rotateLeft.png[width=100%, link="{imagesdir}/Fig8_35a_rotateLeft.svg", window="_blank"]
                                      
                                      a) Left-rotation;

//image::{imagesdir}/Fig8_36b_rotateRight.png[width=75%]
image::{imagesdir}/Fig8_35b_rotateRight.png[width=100%, link="{imagesdir}/Fig8_35b_rotateRight.svg", window="_blank"]
                                      
                                      b) Right-rotation

[.text-center]
Figure 8.35. DRAKON-diagrams of node rotation algorithms used in red-black tree clusters.

// ====================================================================
// SECTION: Red-Black Tree Node Insertion Videos
// This section demonstrates 5 Cases of node insertion in a Red-Black Tree.
// Top panel: navigation buttons (Case 1–5)
// Videos below: vertical list with posters and captions (Figure X)
// ====================================================================

== Видеодемонстрации вставки узлов (Case 1–5)

//
// PANEL OF NAVIGATION BUTTONS
// [.case-buttons] role defined in site.css
// Each button links to the corresponding video section below
//
[.case-buttons]
****
* <<case1,Case 1>>
* <<case2,Case 2>>
* <<case3,Case 3>>
* <<case4,Case 4>>
* <<case5,Case 5>>
****

//
// CASE 1 VIDEO
// Anchor for navigation: [[case1]]
//
[[case1]]
=== Case 1 — Red Uncle (Recolor)

.Video — Case 1
[.text-center]
****
video::video/case1.mp4[poster=video/posters/poster1.png, width=640, controls]
****

// Figure caption
Figure 1 — Insertion of a new node: Case 1 — Red Uncle. Node recoloring demonstration.

//
// CASE 2 VIDEO
//
[[case2]]
=== Case 2 — Left-Right Rotation (Inner)

.Video — Case 2
[.text-center]
****
video::video/case2.mp4[poster=video/posters/poster2.png, width=640, controls]
****

Figure 2 — Insertion of a new node: Case 2 — Left-Right B3:(LR) Inner Rotation.

//
// CASE 3 VIDEO
//
[[case3]]
=== Case 3 — Right-Left Rotation (Inner)

.Video — Case 3
[.text-center]
****
video::video/case3.mp4[poster=video/posters/poster3.png, width=640, controls]
****

Figure 3 — Insertion of a new node: Case 3 — Right-Left B4:(RL) Inner Rotation.

//
// CASE 4 VIDEO
//
[[case4]]
=== Case 4 — Left-Left Rotation (Outer)

.Video — Case 4
[.text-center]
****
video::video/case4.mp4[poster=video/posters/poster4.png, width=640, controls]
****

Figure 4 — Insertion of a new node: Case 4 — Left-Left B1:(LL) Outer Rotation.

//
// CASE 5 VIDEO
//
[[case5]]
=== Case 5 — Right-Right Rotation (Outer)

.Video — Case 5
[.text-center]
****
video::video/case5.mp4[poster=video/posters/poster5.png, width=640, controls]
****

Figure 5 — Insertion of a new node: Case 5 — Right-Right B2:(RR) Outer Rotation.


==== 8.4.3. Deleting a Node from a red-black tree

!!!!!!! https://www.youtube.com/watch?v=OAkmHIR9YkY&t=1421s !!!!!!!!

Removing a node from a red-black tree is a complex process because it depends on the location of the node, the presence of children, and the color of the nodes involved. However, in several common cases, no rebalancing is required at all.

The deletion process in a Red-Black Tree (RBT) consists of the following steps, with special attention paid to maintaining the tree's balancing properties:

1. `Identification and Search:` As with a standard Binary Search Tree (BST) deletion, the algorithm first identifies and locates the node (x) that needs to be removed from the tree structure.

2. `Deletion and Replacement:`
If the node (x) has zero or one child, the deletion is straightforward: remove x and  replace it with its non-NIL child, or with a NIL node if it has no children. If node (x) has two children, its value is replaced by its inorder successor (the minimum node in its right subtree) or its inorder predecessor (the maximum node in its left subtree). The deletion operation is then performed on the successor/predecessor node, which is guaranteed to have at most one child. This replacement process is critical for maintaining the BST property.

3. Color of the Node to be Removed::
The complexity of the balancing operation depends entirely on the color of the node that is actually removed (the node that takes the final position of x, which might be the successor/predecessor).
 
[loweralpha]
.. Deleting a Red Node::
This is the simplest case. A red node does not contribute to the black height of any path. Simply removing it does not violate any RBT properties, and the tree remains balanced.
 
.. Deleting a Black Node::
This is the more complex case. Removing a black node violates the RBT property that requires all paths from the root to the leaf nodes to contain the same number of black nodes (the black height). Restoring this balance requires an iterative rebalancing process.

[arabic, start=4]
4. `Application of Corrective Adjustments`: After a black node is deleted, a rebalancing procedure is initiated to restore the RBT properties. This process involves a series of recoloring and rotations. The "Double Black" Concept: The node that replaces the deleted black node is temporarily marked as "Double Black" (DB). This is a conceptual designation indicating a structural violation: that the path through this node has lost one black node. Corrective Cases (Fix-Up): The core of the rebalancing algorithm involves applying various fix-up cases based on the color and position of the sibling (or brother) of the (DB) node. These cases dictate whether to perform recoloring, a rotation (single or double), or a combination of both to propagate the (DB) violation up the tree until the root or a suitable correction is achieved.

*Simple Cases Where No Rebalancing is Needed*

`Case A`: Deleting a Red Node with No Children
Since the node is red, its removal does not affect the black-height of any path.
The tree remains balanced without any additional operations.
Tree-Cluster: x:R, x←P; P:R|B; 

image::{imagesdir}/Fig8_38_Del_Case_0.png[width=50%]

`Case B`: Deleting a Black Node with One Red Child

The red child replaces the deleted black node and is repainted black.

This preserves the black-height on all paths through this subtree.

Tree-Cluster: x:B, x←P; x_L|x_R:R → Replace x with child (x_L|x_R); P:R|B




To understand the balancing operations, we first introduce the standard notation used throughout this section (Figure 8.37):

x: The node to be deleted, or the "double-black" node that replaces it after deletion.
P: The parent of x.
s: The sibling of x.
s_L, s_R: The left and right children of the sibling s.

image::{imagesdir}/Fig8_37_Term.jpg[width=50%]

[.text-center]
Figure 8.37. Tree node relationship

The deletion algorithm follows three key stages. The following sections detail all possible cases it must address. The final and most complex stage, resolving a "double-black" node, is handled by the `fixDoubleBlack(x)` function. 

*Case 1: The Sibling s is Red*

This is a "gateway" case. A red sibling allows us to perform a rotation to transform the tree into a configuration where the sibling is black, leading to one of the subsequent cases.

[cols="2,1,2,2", options="header"]
|===
| Tree-Cluster (BEFORE) | Violation | Actions | Tree-Cluster (AFTER)

a| x:DB, x←P; P:B; s:R, s→P; s_L:B; s_R:B
| Red sibling blocks direct access to black nephews. Creates an imbalanced subtree.
|

Recolor s to black

Recolor P to red

Left-rotate around P

Re-analyze the new configuration of x (its sibling is now black)
| x:DB, x←P; P:R; s:B, s→P; s_L:B; s_R:B (Now proceed to Case 2, 3, or 4)
|===

//image::{imagesdir}/Fig8_38a_mindMap_deleteNode.png[width=75%]
image::{imagesdir}/Fig8_37a_mindMap_deleteNode.png[width=100%, link="{imagesdir}/Fig8_37a_mindMap_deleteNode.svg", window="_blank"]
a) Intellect map

//image::{imagesdir}/Fig8_38b_deleteNode.png[width=75%]
image::{imagesdir}/Fig8_37b_deleteNode.png[width=100%], link="{imagesdir}/Fig8_37b_deleteNode.svg", window="_blank"]

b) DRAKON-diagram
[.text-center]
Figure 8.37. Node Deletion Algorithm 



*Stage 2: Introducing the "Double-Black" Concept*
If a black node is deleted, the path through its parent now has one less black node. This deficit is conceptualized as a "double-black" node (x), which is the node that replaced the deleted one (or a NIL leaf if it had no children). The goal of the next stage is to "bubble" this extra blackness up the tree until it can be dissolved.

*Stage 3: Resolving the Double-Black Node with `fixDoubleBlack(x)`*
This is the core rebalancing phase. The function `fixDoubleBlack(x)` is called, where x is the double-black node. The resolution depends entirely on the color of x's sibling (s) and that sibling's children (Figure 8.38). 

image::{imagesdir}/Fig8_38a_fixDoubleBlack.png[width=50%]
//image::{imagesdir}/Fig8_38b_fixDoubleBlackStep.png[width=75%]
image::{imagesdir}/Fig8_38b_fixDoubleBlackStep.png[width=100%, link="{imagesdir}/Fig8_38b_fixDoubleBlackStep.svg", window="_blank"]
[.text-center]
Figure 8.38. DRAKON-diagram of the node structure correction algorithm when removing "double black node" 

The following table provides a complete guide to the cases handled by fixDoubleBlack. The key is to identify the configuration of the sibling (s) and its children to determine the correct sequence of rotations and recolorings.

Table 8.4 — `fixDoubleBlack(x)` Resolution Cases

[cols="1,2,2,2,2", options="header"]
|===
| Case | Sibling (s) & Nephews | Description | Actions | Outcome
| 1
| s is red
|
The sibling is red. This is a gateway case to the other cases.
|

Recolor s to black

Recolor x.parent to red

Rotate left if x is left child (right otherwise)

Re-enter `fixDoubleBlack(x)` for the new sibling (which is now guaranteed to be black).
|
Transforms the problem into a case with a black sibling (2, 3, or 4).

| 2
| s is black, and both of s's children are black
|
The sibling cannot lend a black node.
|

Recolor s to red

Move the double-black problem upward by setting x = x.parent.

If the new x is red, it becomes black (problem solved).

If the new x is the root, stop.

Otherwise, recurse with fixDoubleBlack(new x).
|
The double-black "bubbles up" to the parent.

| 3
| s is black, and at least one of s's children is red.
| This case has sub-cases based on the configuration.
|
*See sub-cases 3a-3d below.*
|
The double-black is eliminated via rotations.
|===

Sub-cases of Case 3 (Black Sibling with a Red Child):

[cols="1,3,4", options="header"]
|===
| Sub-case | Configuration (x is left child) | Actions
| 3a (L-L)
| s is the right child, and s's right child is red.
|

Recolor s to the color of x.parent

Recolor x.parent to black

Recolor s.right to black

Left-rotate around x.parent

| 3b (L-R)
| s is the right child, and s's left child is red (right is black).
|

Recolor s.left to black

Recolor s to red

Right-rotate around s

This transforms the case into 3a (L-L). Apply 3a.

| 3c (R-R)
| s is the left child, and s's left child is red.
|

Recolor s to the color of x.parent

Recolor x.parent to black

Recolor s.left to black

Right-rotate around x.parent

| 3d (R-L)
| s is the left child, and s's right child is red (left is black).
|

Recolor s.right to black

Recolor s to red

Left-rotate around s

This transforms the case into 3c (R-R). Apply 3c.
|===






[cols="1,2,2,2,1", options="header"]
|===
| Case | nodeImage | Description | Required Actions | fixDoubleBlack?

| 1 | x:R, x.leaf | Red leaf node (no children) | Remove directly | No

| 2 | x:B, x<- P; x.child=R | Black node with one red child | Promote child, recolor to black | No

| 3 | x:B, x<- P; x.child=B or NIL | Black node with black or null child | Double-black arises | fixDoubleBlack(x) | Yes

| 4 | x:B, x has 2 children; y = min(x.right); y.child=null | Two children, successor is direct child | Replace with y, transplant | Maybe

| 5 | x:B, x has 2 children; y = min(x.right); y.child ≠ null | Two children, successor has child | Replace with y, transplant + reconnect y's child | Maybe
|===

[cols="1,2,2,2,1", options="header"]
|===
| Case | Informational Image of the Node | Description | Required Actions | fixDoubleBlack?

| 1 | Red leaf node (no children) | Remove directly | No fix required | No
| 2 | Black node with one red child | Promote child and repaint | Repaint child to black | No
| 3 | Black node with one black/null child | Double-black arises | Call fixDoubleBlack(x) | Yes
| 4 | Node with two children, direct successor | Replace with direct successor | Simple transplant | Maybe
| 5 | Node with two children, indirect successor | Replace with successor + rewire subtrees | Transplant + update structure | Maybe
|===

Replacing a node in a red-black tree using `joinParentChild` is shown on Figure 8.39
[caption="Figure 8.40", align="center"]

image::{imagesdir}/Fig8_39_joinPC.png[width=80%]

[.text-center]
Figure 39. Replacing a node in a red-black tree

The top diagram illustrates the replacement of node U (`9`) with subtree V (`7`) before calling `joinParentChild(tree, U, V)`.  
The bottom diagram shows the result of the operation: node `7` has taken the place of `9`, preserving the tree's structure and balance.

Consider in more detail the different instances of the removal node in
the structure of the red-black tree. In the first step, the node is
removed simply as a node in the binary search tree. If the replacement
node is a "red" node, or if the removed node is a "red" node, the
removed node is replaced by another node. There is no need to make any
further changes to the tree structure (fig.8.40).

image::{imagesdir}/Fig8_40_delRed.png[width=80%]

[.text-center]
Figure 8.40. Deletion of red node (20)

If the node to be deleted and the node that replaces it are black nodes,
a situation called a "double black node" occurs. In this case, some
additional operations must be performed to ensure that the properties of
the red-black tree are preserved. The DRAKON-diagrams algorithm of this
process is shown in Fig.8.41.

image::{imagesdir}/Fig8_41_fixDoubleBlack.png[width=80%]

//image::{imagesdir}/Fig8_42b_fixDoubleBlackStep.png[width=100%]
image::{imagesdir}/Fig8_41b_fixDoubleBlackStep.png[width=100%, link="{imagesdir}/Fig8_41b_fixDoubleBlackStep.svg", window="_blank"]

[.text-center]
Figure 8.41. DRAKON-diagram of the node structure correction algorithm when removing "double black node"

If the replacement node is a leaf node (i.e., has no child nodes), we
replace the node with a "zero" leaf node and color it black. If the
replacement node has one child node, we replace the node with its child
node and color it black. If the replacement node has two child nodes, we
replace the node with its subsequent node in order, and then delete the
next node in order (which is no more than a node with one child node)
using the method described above.

image::{imagesdir}/Fig8_43_delRed.png[width=80%]

Figure 8.43. DRAKON-diagram of the node structure correction algorithm
when removing "double black node"

If a node is deleted and replaced with another node, the properties of
the red-black tree may be compromised. To restore them, the following
operations must be performed:

[arabic]
{empty} If the node to be deleted is red, the properties of the red-black tree
are not disturbed. If the replacement node is red, it should be
repainted black.

{empty}2. Next, rotate, recolour the nodes and/or transfer the
"blackness" (the number of black nodes relative to the red ones) up the
tree until the tree is balanced.

{empty}3. At the same time, you need to make sure that the root of the
tree is black.

Let's consider options for restoring the properties of red-black tree.
Enter the following notations: the node to be deleted is "x", the child
node of the deleted node is "y", and the sibling of the node to be
deleted is "s" (Figure 8.43).

image::{imagesdir}/Fig8_43_Term.jpg[width=100%]

[.text-center]
Figure 8.43. Tree node relationship


Option 1: If the child element (y) of the node to be deleted (x) is
coloured red, then after deletion it should be recoloured black, as a
result of which the number of black nodes will be restored (Figure
8.40).

image::{imagesdir}/Fig8_39_Term.jpg[width=100%]
image::{imagesdir}/Fig8_42b_fixDoubleBlackStep.png[width=100%, link="{imagesdir}/Fig8_42b_fixDoubleBlackStep.svg", window="_blank"]

[.text-center]
Fig. 8.40. Deleting and repainting the child of the node to be removed
(y)

Option 2: When the sib(s) of the node to be deleted (x) is coloured
black, and at least one of the descendants is red, then four different
combinations are possible:

• Option 2(a): The brother(s) of the node to be deleted (x) is black. In
this case, the brother (s) is the left descendant of the parent (P), and
the left child of the brother is coloured red. This is the so-called
"left-left _configuration"_, in which the balance is achieved by the
right rotation, after which the color of the child should be replaced by
black (Fig. 8.41).

image:media/image44.jpg[media/image44,width=427,height=165]

Figure. 8.41. Left-Left node delete configuration

Option 2(b): Mirror image of case 2(a). The "s" brother is his parent's
right child, and his right child is the red child. The right-right
configuration performs a left-hand rotation. The child node is then
changed to black. As a result, the black node counter property is
restored (Fig. 8.42).

image:media/image45.jpg[media/image45,width=412,height=123]

____
Figure 8.42. Right-Right configuration of node deletion
____

Option 2 (c). The brother (s) of the remote node (y) is black. The
brother(s) is the left offspring of his parent, and his right child is
red. This is a left-to-right configuration, so a left rotation is
performed followed by a right rotation. The child node is coloured black
(Figure 8.43):

image:media/image46.jpg[media/image46,width=670,height=121]

Figure 8.43. Left-Right node delete configuration

Option 2(d): The brother (s) of the remote node (y) is coloured black.
The brother (s) is the right child of his parent (P) and his left child
is the red child. A right-left rotation is then performed, followed by a
left-hand rotation. The color of the child node changes to black (Fig.
8.44).image:media/image47.jpg[media/image47,width=670,height=121] Figure
8.44. Right-Left node delete configuration

Option H: If the node (y) to be removed and its brother(s) are coloured
black and both of its descendants are missing, i.e. black by definition,
then you need to recolour the children red and recursively add black to
the parent. If the parent was red, then it became black. If the parent
was black, it would become double black. If the parent is the root, then
it remains black. For example, below is a case where the node (y) to be
deleted and its brother (s) are black (Figure 8.45):

image:media/image48.png[media/image48,width=477,height=176]

Figure 8.45 The Process of rebuilding a tree with two black nodes (y)
and (s)

Option 4: If the sib(s) of the node to be removed (y) is coloured red,
then a rotation is performed to achieve the balance of the tree. The
sister nodes are then repainted. For example, consider the following
option (Fig. 8.46):

image:media/image49.jpg[media/image49,width=670,height=169]

Figure 8.46. The process of rebuilding a tree with two nodes (y) and (s)
of different colours

Conclusion

Trees are one of the most important data structures in computer science,
used to represent hierarchical relationships and organize data. They
provide efficient search, insert, and delete operations, making them
ideal for use in a variety of applications.

AVL trees, named after their creators Adelsky-Velsky and Landis, are
balanced binary search trees. They provide fast search, insertion, and
deletion by keeping the height of the tree logarithmic relative to the
number of nodes. However, AVL trees require additional insertion and
deletion operations to maintain balance, which can be a disadvantage in
some applications.

Red-black trees are another type of balanced binary search trees. They
provide efficient search, insert, and delete operations, but can be more
difficult to implement because of the additional properties they must
support. They are widely used in many standard libraries.

The choice of a specific tree type depends on the specific requirements
of the application. AVL trees are generally preferred when frequent
searches are the most important operations, as they provide a more
stringent balance than red-black trees. On the other hand, red-and-black
trees can be more effective with frequent insertions and removals, as
they require fewer turns to maintain balance.

It's important to remember that both types of trees require additional
memory to store balance information, and both can be difficult to
implement. In some cases, other data structures, such as hash tables or
B-trees, may be more appropriate. However, despite these challenges,
trees continue to play a central role in computer science and are a key
tool for any programmer.

[width="99%",cols="28%,^5%,^8%,^12%,^6%,^8%,^8%,^8%,^9%,^8%",options="header",]
|===
| |Tree type | | | | | | | |
| |Binary | | |AVL | | |Red-Black | |

a|
Time Complexity:

Insert, Find, Delete

|1 |2 |3 |1 |2 |3 |1 |2 |3

| |O(N) |O(sqrt(N)) |O(logN) |O(logN) |O(logN) |O(logN) |O(logN)
|O(logN) |O(logN)

|Space Complexity |Iterative | |Recursive | |O(N) |O(N) |O(N) |O(N) |

| |O(1) | |O(H)=O(sqrt(N)) | | | | | |
|===
