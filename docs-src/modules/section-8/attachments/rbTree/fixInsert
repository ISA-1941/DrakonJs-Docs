function fixRedRed(tree, x) {
  if (x === tree.root) {
    x.colour = BLACK;
    return;
  }

  let done = false;
  while (!done && x.parent.colour === RED) {
    const P = x.parent;
    const G = P.parent;
    const U = (P === G.left) ? G.right : G.left;
    const nodeImage = buildNodeImage(x, P, G, U);

    if (nodeImage === "x.R; P.R^P←G; U.R") {
      // Case A (uncle is red)
      P.colour = BLACK;
      U.colour = BLACK;
      G.colour = RED;
      x = G;
      // Instead of 'continue', just loop back naturally:
      // we leave done = false, so the while condition is rechecked.
      // (No break; no continue; is needed.)
    }
    else if (nodeImage === "x.R^x→P; P.R^P←G") {
      // Case B1 (Left-Right triangle)
      rotateLeft(tree, P);
      // Fall-through into the B2 (Left-Left) case:
      // After rotation, x and P have swapped roles.
      // (We do not set done yet; let the next if catch it.)
      // 
      // ***because we just rotated, fall through to the next check***
    }
    else if (nodeImage === "x.R^x←P; P.R^P←G") {
      // Case B2 (Left-Left line)
      rotateRight(tree, G);
      P.colour = BLACK;
      G.colour = RED;
      done = true;   // Exit the loop instead of 'break;'
    }
    else if (nodeImage === "x.R^x←P; P.R^P→G") {
      // Case B1 (Right-Left triangle)
      rotateRight(tree, P);
      // fall through to the next check
    }
    else if (nodeImage === "x.R^x→P; P.R^P→G") {
      // Case B2 (Right-Right line)
      rotateLeft(tree, G);
      P.colour = BLACK;
      G.colour = RED;
      done = true;   // Exit loop 
    }
    else {
      // no matching case → exit
      done = true;
    }
  } // end while

  tree.root.colour = BLACK;
}
