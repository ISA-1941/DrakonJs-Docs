<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Drakon.js Docs</title>
    <link rel="canonical" href="https://ISA-1941.github.io/DrakonJs-Docs/drakonjs-docs/3.1.10/section-8/section-8_new.html">
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://ISA-1941.github.io/DrakonJs-Docs">Drakon.js Docs</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="drakonjs-docs" data-version="3.1.10">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">drakonjs-docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../index.html">Introduction</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Abstract Data Types</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-1/section-1.html">ADT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">JavaScript View</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-2/section-2.html">JavaScript</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Implementation base types</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-3/section-3.html">Implementation base types</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Language Drakon</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-4/section-4.html">Visual Language Drakon</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Complexity of algorithms</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-5/section-5.html">Complexity problems</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Basic search  algorithms</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-6/section-6.html">Base Search Algorithms</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Base algorithms sorting</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-7/section-7.html">Base Sorting Algorithms</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Binary Tree Algorithms</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="section-8.html">Binary Tree Algorithms</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">drakonjs-docs</span>
    <span class="version">3.1.10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">drakonjs-docs</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">3.1.10</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<div class="edit-this-page"><a href="https://github.com/ISA-1941/DrakonJs-Docs/edit/main/docs-src/modules/section-8/pages/section-8_new.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1 text-justify">
<h2 id="_section_8_binary_tree_algorithms"><a class="anchor" href="#_section_8_binary_tree_algorithms"></a>SECTION 8. BINARY TREE ALGORITHMS</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_8_1_representation_of_binary_trees"><a class="anchor" href="#_8_1_representation_of_binary_trees"></a>8.1 Representation of binary trees</h3>
<div class="paragraph">
<p>A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left and right child. The topmost node is called the root, and nodes with no children are called leaves.
Four types of imbalanced states exist.
Binary trees as an abstract data type were discussed in the first
section, here we will talk about the computer implementation of this
type of data structures using the visual algorithmic language DRAKON and
the programming language JavaScript. Recall the basic terminology of binary trees (Figure 8.1):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_1_Term.jpg" alt="Fig8 1 Term" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.1. Basic tree terminology</p>
</div>
<div class="paragraph">
<p><em>Root:</em> The root of the tree is the only node with no incoming edges. It
is the top node in the tree;</p>
</div>
<div class="paragraph">
<p><em>Node:</em> This is the basic element of the tree. Each node has data and
two references that can point to zero or its descendants;Edge: This is
also the fundamental part of the tree and is used to connect the two
node points.</p>
</div>
<div class="paragraph">
<p><em>Path:</em> A path is an ordered list of nodes connected by edges.</p>
</div>
<div class="paragraph">
<p><em>Leaf:</em> A leaf node is a node that has no descendants.</p>
</div>
<div class="paragraph">
<p><em>Tree height:</em> The height of a tree is the number of edges on the
longest path between the root and the leaf.</p>
</div>
<div class="paragraph">
<p><em>Node level:</em> Node level is the number of edges on the path from the
root node of this node.</p>
</div>
<div class="paragraph">
<p>The information structure of the binary tree is organised as follows (Figure 8.2):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_2_BST.jpg" alt="Fig8 2 BST" width="50%">
</div>
</div>
<div class="paragraph text-center">
<p>Fig.8.2 Binary tree structure (<em>info</em> - value (key), (N - NULL))</p>
</div>
<div class="paragraph">
<p>Several types of binary trees are discussed in the training literature, the most important of which is classification based on node values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a binary search tree;</p>
</li>
<li>
<p>AVL-Tree;</p>
</li>
<li>
<p>Red-Black Tree.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_8_2_binary_search_tree"><a class="anchor" href="#_8_2_binary_search_tree"></a>8.2 Binary search tree</h3>
<div class="sect3">
<h4 id="_8_2_1_building_a_binary_tree"><a class="anchor" href="#_8_2_1_building_a_binary_tree"></a>8.2.1 Building a binary tree</h4>
<div class="paragraph">
<p>If the tree is organised in such a way that, for each node, all the node
values of its left subtree are less than this node and all the values of
its right subtree are greater, it is called a binary search tree. A BST
is a recursive data structure because each subtree is also a tree. A BST
has the following tree properties consists of nodes that retain unique values;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>each node has zero, one or two child nodes;</p>
</li>
<li>
<p>one of the nodes is referred to as the root node, which is at the top of the tree structure;</p>
</li>
<li>
<p>each node has only one parent node, except for the root node which has
no parent node;</p>
</li>
<li>
<p>the value of each node is greater than that of its left child but less than that of its right child;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A binary search tree is built according to a certain algorithm. Consider the sequence of integers \{11, 5, 17, 15, 1, 8, 19, 13, 21}, represented as a slice of numbers[]. First the root node {11} is formed, then in the loop for each node recursively the method
<code>insert(tree, value)</code> is called (Fig. 8.3 a), which in turn calls the method <code>createNode(value)</code>, which creates a new node (Fig. 8.3 b).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_3a_insert.svg" target="_blank" rel="noopener"><img src="_images/Fig8_3a_insert.png" alt="Fig8 3a insert" width="100%"></a>
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/ig8_3b_createNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_3b_createNode.png" alt="Fig8 3b createNode" width="75%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Fig.8.3 Binary tree DRAKON-diagrams
a) building a tree by insert(node,value); b) creating a node</p>
</div>
<div class="paragraph">
<p>The complete process of creating a binary tree is shown in Figure 8.4.
The first number 11 is written to the root of the tree. The second
number 5 is less than the value in the tree root, so it is written to
the left subtree. The next number 17 is greater than the root number, so
it is written to the right subtree. Then the number 15 is greater than
the value at the root of the tree, so it is written to the right
subtree, but the right subtree is already built. The number 15 is
compared to the number 17 at the root of the right subtree. Since the
value to be added is less than the value in the root of the right
subtree, we add the left subtree to this node. The final result is a
binary search tree with three variants: a node 5 is the parent of two
children (1,8), a node 15 has only a left child, and a node 19 has only
a right child. This arrangement of nodes is chosen to demonstrate the
function of removing nodes, which will be discussed later.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_4_treeProcess.svg" target="_blank" rel="noopener"><img src="_images/Fig8_4_treeProcess.jpg" alt="Fig8 4 treeProcess" width="125%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.4. Building a binary tree</p>
</div>
<div class="paragraph">
<p>8.2.3 Finding a node based on a set value</p>
</div>
<div class="paragraph">
<p>Another basic operation is the <code>findNode(value)</code> function. This function uses a JavaScript instructions construct, which recursively compares the value of
val with the values of other nodes as it traverses the tree.
The DRAKON-diagram of the `findNode(node, value)`function is shown in Figure 8.5.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_5_findNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_5_findNode.png" alt="Fig8 5 findNode" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.5. DRAKON-diagram of Node Finding Algorithm</p>
</div>
<div class="paragraph">
<p>8.2.3 Deleting a node with a specified value</p>
</div>
<div class="paragraph">
<p>The next basic operation is to delete a node with the specified  value. The function <code>removeNode (node,value)</code> is used recursively.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s analyse in more detail the order in which the nodes are moved in these variants.</p>
</div>
<div class="paragraph">
<p><em>Option a):</em> Node (21) has no descendants (Figure 8.6.).</p>
</div>
<div class="paragraph">
<p>In this case, this node is removed by changing the value of <code>node = null</code> in the parent node. Figure 8.6. shows the process of deleting node (21)
and the corresponding DRAKON-diagram fragment</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_6_del21.png" alt="Fig8 6 del21" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.6. Deleting a node without childs</p>
</div>
<div class="paragraph">
<p><em>Option b):</em> Node (19) has a right-hand descendant (Figure 8.7).</p>
</div>
<div class="paragraph">
<p>In this case, node (19) is removed from the tree by replacing its
address in the parent node (17) with the address of its only descendant
node (21). Figure 8.7. shows the process of removing node (19) and the corresponding DRAKON-diagram fragment.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_7_del19.png" alt="Fig8 7 del19" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.7. Deleting node (19) with right-hand descendant</p>
</div>
<div class="paragraph">
<p><em>Option c):</em> Node (8) has a left-hand child (Figure 8.8.).</p>
</div>
<div class="paragraph">
<p>In this case, node (8) is removed from the tree by replacing its
address in parent node (5) with the address of its only left child node (6). Figure 8.8. shows the process of removing node (8) and the
corresponding DRAKON-diagram fragment.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_8_del8.png" alt="Fig8 8 del8" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.8. Deleting node (8) with left-hand child</p>
</div>
<div class="paragraph">
<p><em>Variant d):</em> Node (5) has two descendants (Figure 8.9.). In this case
the binary search tree is rearranged: node (2) moves to the place of node (5):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_9_del5.png" alt="Fig8 9 del5" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.9. Deleting a node (5) with two childs</p>
</div>
<div class="paragraph">
<p>DRAKON-diagram of the minimum value search method is shown in Fig8.10.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_10_findMin.png" alt="Fig8 10 findMin" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.10. DRAKON-diagram of the minimum value search method</p>
</div>
<div class="paragraph">
<p>The complete DRAKON-diagram of the removal of nodes from a binary search tree is shown in Figure 8.11.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_11_removeNode.svg" alt="Fig8 11 removeNode" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.11. DRAKON-diagram of the removal of nodes</p>
</div>
<div class="paragraph">
<p>8.2.4. Traversing the binary search tree</p>
</div>
<div class="paragraph">
<p>One of the basic tree operations is to traverse tree nodes. Unlike linear data structures, where elements are traversed in a linear order, tree nodes can be traversed in a variety of ways.
The traversal, in which each ancestor node is viewed before its descendants, is called a pre-ordered walk or direct-order traversal (<em>pre-order walk</em>). There is also an <em>in-order walk</em>, where the left subtree is visited from bottom to top, then the root node, then the right subtree. The traversal, in which first descendants are viewed and then ancestors, is called a post-ordered or reverse-order traversal (<em>post-order walk</em>). All three cases, including the Dragon diagrams, are shown in the Figure 8.12.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_12_PreInPost.jpg" alt="Fig8 12 PreInPost" width="100%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.12. Three Classical Tree Traversals: Pre-, In-, Post-Order</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_3_self_balancing_binary_trees_avl_trees"><a class="anchor" href="#_8_3_self_balancing_binary_trees_avl_trees"></a>8.3 Self-balancing binary trees (AVL-trees)</h3>
<div class="paragraph">
<p>The efficiency of any tree operation depends substantially on the order in which the input data is received. For example, if an incoming sequence of numbers is partially sorted in ascending or descending order, this structure will no longer look like a tree (Figure 8.13).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_13.png" alt="Fig8 13" width="25%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.13. Partially sorted input data</p>
</div>
<div class="paragraph">
<p>In such practically "degenerate" trees, the complexity of the operations is determined by the number of nodes, i.e. it is almost linear - O(n).
The left and right subtrees are unbalanced, which can be estimated by the balance coefficient (kb), which is equal to the difference between the heights of the left and right subtrees. Recall that the height of a tree is defined as the length of the longest branch in a subtree (sum of edges). For an ideal binary search tree (a tree where the number of nodes in the left subtree is equal to the number of nodes in the right subtree), this factor is 0 (Figure 8.14).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_14_treeIdeal.svg" target="_blank" rel="noopener"><img src="_images/Fig8_14_treeIdeal.png" alt="Fig8 14 treeIdeal" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.14. An ideal binary tree</p>
</div>
<div class="paragraph">
<p>In real life, ideal binary trees are almost never achieved; programmers often try to build a tree where the height of the left subtree differs from the height of the right subtree by no more than 1. Such trees are called AVL-trees; for such trees the complexity of operations is defined as O(logn), i.e. the execution time of basic operations (search, remove) is significantly less than for BST-trees.</p>
</div>
<div class="paragraph">
<p>The algorithms for such trees are based on the process of balancing the tree when a new node is inserted or an existing node is removed. The purpose of balancing is to reconstruct the tree so that the heights of the left and right subtrees do not differ by more than 1. The balancing factor must satisfy the following conditions allowable values kb = -1, 0 and +1;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The value kb = -1 indicates that the right subtree "outweighs" the
left subtree;</p>
</li>
<li>
<p>The value kb= +1 indicates that the left subtree "outweighs" the right
subtree;</p>
</li>
<li>
<p>a value of kb = 0 indicates that the tree contains an equal number of
nodes on each side, i.e. the tree is perfectly balanced.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The balancing algorithm in its most general form is presented in the following DRAKON-scheme (Figure 8.15)</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_15_buildingAvlTree.svg" target="_blank" rel="noopener"><img src="_images/Fig8_15_buildingAvlTree.png" alt="Fig8 15 buildingAvlTree" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.15. The balancing algorithm in its most general view</p>
</div>
<div class="paragraph">
<p>The balancing technique boils down to making circular movements of the nodes in four variants:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>right turn (RR);</p>
</li>
<li>
<p>Left turn (LL);</p>
</li>
<li>
<p>Right - left turn (RL);</p>
</li>
<li>
<p>Left to right turn (LR).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The right-hand turn is performed when the root node has a balance factor kb = +2 and its left-hand child has a balance factor kb = +1 (Figure 8.16):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_16_RR_turn.jpg" alt="Fig8 16 RR turn" width="100%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.16. Right turn</p>
</div>
<div class="paragraph">
<p>The left-hand turn is performed when the root node has a balanced kb = - 2 and its right-hand descendant has a balanced kb = - 1 (Figure 8.17):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_17_LL_turn.jpg" alt="Fig8 17 LL turn" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.17. Left turn</p>
</div>
<div class="paragraph">
<p>A right-left turn is performed when the root node has a balance factor
kb = -2 and its right-hand child has a balance factor kb = +1 (Figure
8.18):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_18_RL_turn.jpg" alt="Fig8 18 RL turn" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.18. Right-left turn</p>
</div>
<div class="paragraph">
<p>Left-right rotation is performed when a node has a balance factor of kb = +2 and its left child has a balance factor of kb = -1 (Figure 8.19):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_19_LR_turn.jpg" alt="Fig8 19 LR turn" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.19. Left-right turn</p>
</div>
<div class="paragraph">
<p>Consider the balancing process in more detail with an example of tree formation when input data is received in this order: [1, 2, 5, 6, 8, 11, 13, 15, 17, 19, 21]. As shown above, such a tree is unbalanced.</p>
</div>
<div class="paragraph">
<p>Balance checking are started on the arrival of each new node using the <code>insertNode(node, value)</code> function, which determines the position of the new node in the left or right subtree relative to the root node. The choice of the balancing path is determined by the method
<code>rotateInsert(node, value)</code>. A DRAKON-diagrams of the algorithms of the above methods is shown in Figure 8.20.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_20_insertNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_20_insertNode.png" alt="Fig8 20 insertNode" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.20. DRAKON-diagram depicting the method of inserting node</p>
</div>
<div class="paragraph">
<p>The choice of one of the possible balancing paths (rotations) is determined by the <code>rotateInsert(node, val)</code> function (Figure 8.21).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_21_rotateInsert.svg" target="_blank" rel="noopener"><img src="_images/Fig8_21_rotateInsert.png" alt="Fig8 21 rotateInsert" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.21. DRAKON-diagram depicting the inserting node method</p>
</div>
<div class="paragraph">
<p>Depending on the location of the new node relative to the parent node and the balance factor values, the left-hand or right-hand rotation methods are performed (Figure 8.22):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_22_twoRotates.svg" target="_blank" rel="noopener"><img src="_images/Fig8_22_twoRotates.jpg" alt="Fig8 22 twoRotates" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.22. Node rotation programme codes</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the tree rebuilding process in detail as a result of using the <code>rotateInsert(node, val)</code> method on the example of entering the values of three nodes (5,6,8). After receiving the value of last node (8), a "twig" appears instead of the tree that needs to be balanced. In this case the condition in the <code>rotateInsert(node, val)</code> method is met: the balancing factor is 2 and the value of node (8) is more,than the parent node (6) and the <code>rotateLeft(node)</code> method is called. The balancing process in this case is shown in Figure 8.23:</p>
</div>
<div class="imageblock unresolved text-center">
<div class="content">
<img src="_images/Fig8_23_exampleLL.jpg" alt="Fig8 23 exampleLL" width="75%">
</div>
</div>
<div class="paragraph">
<p>Figure 8.23. Example of Left-Left turn balancing</p>
</div>
<div class="paragraph">
<p>The process of new nodes arriving and rebuilding the resulting AVL-tree by balancing for the input set [1,2,5,6,8,11,13,15,17,19,21] is shown in Figure 8.24.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_24_avlTreeProcess.jpg" alt="Fig8 24 avlTreeProcess" width="100%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.24. Process of building a balanced AVL-tree</p>
</div>
<div class="paragraph">
<p>DRAKON-diagram of the AVL-trees basic operation `findNode(node, val)is shown in Figure 8.25:</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_25_findNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_25_findNode.png" alt="Fig8 25 findNode" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.25. DRAKON-diagram depicting the finding a node method</p>
</div>
<div class="paragraph">
<p>Another basic operation, deleting a node with a specified value, consists of the following steps. The node is searched from the root down through the branches to the node to be deleted. The following situations may occur (Figure 8.27):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_26_varDelNode.jpg" alt="Fig8 26 varDelNode" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.26. Cases for nodes to be removed</p>
</div>
<div class="paragraph">
<p>a) The node to be deleted has two non-empty descendants;</p>
</div>
<div class="paragraph">
<p>b) The node to be deleted has no descendants;</p>
</div>
<div class="paragraph">
<p>c) The node to be deleted has one descendant (left or right).</p>
</div>
<div class="paragraph">
<p>As with the other methods, a node with a c value is first recursively identified and then one of the options presented is selected. A DRAKON-diagram of the algorithm for deleting a node with the cases for nodes to be removed value is shown in Figure 8.27.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_27_deleteNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_27_deleteNode.png" alt="Fig8 27 deleteNode" width="75%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.27. DRAKON-diagram depicting an algorithm for removing a node
with a specified value</p>
</div>
<div class="paragraph">
<p>The <code>main()</code> program inputs an array of data, searches for a node with a
specified  value, and deletes a node with a specified value (Figure 8.28).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_28_mainFunction.svg" target="_blank" rel="noopener"><img src="_images/Fig8_28_mainFunction.svg" alt="Fig8 28 mainFunction" width="75%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.28. DRAKON-diagram of the main-function</p>
</div>
</div>
<div class="sect2">
<h3 id="_8_4_red_black_trees"><a class="anchor" href="#_8_4_red_black_trees"></a>8.4 Red-black trees</h3>
<div class="sect3">
<h4 id="_8_4_1_inserting_a_new_node_and_the_balancing_process"><a class="anchor" href="#_8_4_1_inserting_a_new_node_and_the_balancing_process"></a>8.4.1. Inserting a new node and the balancing process</h4>
<div class="paragraph">
<p>A red-black tree is a variant of a self-balancing binary search tree in which the nodes are placed according to a certain rule and coloured red or black (Figure 8.29)</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_29_redblackTree.jpg" alt="Fig8 29 redblackTree" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.29. Red-Black Tree</p>
</div>
<div class="paragraph">
<p>The nodes containing data (in this case, integers) are internal. In
addition, red-black trees contain imaginary, "null" nodes associated
with tree leaves (Null - in Figure 8.29). Red-black trees satisfy all
the properties of a binary search tree and must have the following
properties:</p>
</div>
<div class="paragraph">
<p>1. Each node is coloured red or black.</p>
</div>
<div class="paragraph">
<p>2. The root of the tree is always black.</p>
</div>
<div class="paragraph">
<p>3. All leaves are black (Null).</p>
</div>
<div class="paragraph">
<p>4. Both descendants of the red node are black, i.e. there cannot
be consecutive red nodes.</p>
</div>
<div class="paragraph">
<p>5. All simple paths from the node to the descending leaves
contain the same number of black nodes.</p>
</div>
<div class="paragraph">
<p>Unlike AVL trees, where balance is achieved by balancing the heights of the left and right subtrees, red-black balance is achieved by the properties mentioned above. Adding or removing a node from the red-black
tree can disrupt the red-black tree properties, and restoring balance is achieved by two operations: repainting the nodes and/or rebuilding the whole tree or its subtrees using specific rotations.The most important of these properties are properties 4 and 5.</p>
</div>
<div class="paragraph">
<p>Property 4 dictates a critical aspect of red-black trees: both descendants of the red node are black.</p>
</div>
<div class="paragraph">
<p>Property 5 builds on this by enforcing a uniform "black-height" for all paths from any node to its leaf descendants. Regardless of the specific path taken, the count of black nodes remains constant.</p>
</div>
<div class="paragraph">
<p>Understanding the dynamic enforcement of these properties is crucial for developing an algorithm that maintains a balanced red-black tree structure. However, achieving this insight often presents significant challenges, as it requires tracking the state of multiple nodes simultaneously.</p>
</div>
<div class="paragraph">
<p>To facilitate conceptual clarity, we can employ an analogy: imagine black nodes as weights and red nodes as springs connecting these weights. In this model, the black nodes (weights) provide the stability and physical equilibrium of the tree structure, while the red nodes serve as a flexible resource capable of transforming into black nodes when necessary.</p>
</div>
<div class="paragraph">
<p>In other words, the red-black tree balancing algorithm can be interpreted as a balancing state machine (balancing automaton) with only two primary functions: rotating the tree (redistributing weight) and converting red 'springs' into black 'weights.' This visualization helps to intuitively grasp how the red-black tree properties work in concert to maintain the overall stability of the system</p>
</div>
<div class="paragraph">
<p>Black height is a fundamental concept in our engineering model. It represents the total 'weight' of a specific branch, calculated as the number of black nodes (weights) on any single path from node x to a leaf.</p>
</div>
<div class="paragraph">
<p>Properties 4 and 5 work together to maintain the structural integrity of the tree. While red nodes (springs) allow certain branches to stretch, the rules ensure that the longest path (a sequence alternating between weights and springs) is never more than twice the length of the shortest path (consisting only of weights). This constraint ensures that the 'tension' in the tree is evenly distributed, guaranteeing that the tree remains approximately balanced with a height of O(log n), where n is the number of nodes."</p>
</div>
<div class="paragraph">
<p>To perform the above operations at the program level, a red-black tree is first created, for which two user types - <code>node</code> and <code>rbTree</code> are declared:
Node includes the following fields: <code>data</code> - node numeric value,  <code>color</code> - node color type bool: <code>red node</code> - true; <code>black node</code> - false, <code>left</code>, <code>right</code> and <code>parent</code> nodes. In turn <code>rbTree structure</code> represents the reference type variable, that store objects containing not the "value" itself but a reference to the memory area where this object is stored (Fig. 8.30).</p>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_30a_makeNode.png" alt="Fig8 30a makeNode" width="100%">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_30b_makeRBTree.png" alt="Fig8 30b makeRBTree" width="75%">
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph text-center">
<p>Figure 8.30. DRAKON-diagram of Node and Tree Description</p>
</div>
<div class="paragraph">
<p>The insertion of a new node into a red-black tree is performed by the rbInsert(tree, key) function. It adds a new red node (a 'spring') to the tree, following the standard rules of a binary search tree. However, adding this new component may cause a local instability, most commonly violating the 'no two consecutive red nodes' rule—essentially, placing two flexible springs together, which weakens the structure.</p>
</div>
<div class="paragraph">
<p>To restore equilibrium, the balancing state machine analyzes a local configuration of nodes, which we shall designate as a tree-cluster. This cluster consists of the newly added node x, its parent P, grandparent G, and uncle U. Think of this cluster as a local 'mechanical link' where the tension must be adjusted.</p>
</div>
<div class="paragraph">
<p>We define this substructure as a nodeImage. By examining the colors and positions within this image, the algorithm determines whether it needs to 'harden' a spring into a weight or physically shift the weights through rotation.</p>
</div>
<div class="paragraph">
<p>All canonical nodeImages configurations, representing possible arrangements of weights and springs, are summarized in Table 8.3. This table illustrates how each type of structural instability is detected and corrected by the balancing automaton to preserve the equilibrium of the red-black tree. The following node designations are used throughout this table:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>x: The newly inserted red node — a 'spring' causing a potential violation.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>P: Parent of x.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>G: Grandparent of x (parent of P). In our model, G is always a 'weight' (black) before the fixup begins.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>U: Uncle of x (sibling of P). If the uncle is missing (null), it is treated as a static black 'weight.'</pre>
</div>
</div>
<div class="paragraph">
<p>Color notation: R – Red (Spring), B – Black (Weight).</p>
</div>
<div class="paragraph">
<p>Rotation: A mechanical reconfiguration performed around a node, relinking its components to redistribute the weight while strictly maintaining the binary search tree order.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_31_family.jpg" alt="Fig8 31 family" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.31. Designation of the degree of "kinship" of RB Tree nodes (cluster) (x, P, G, U, S)</p>
</div>
<div class="paragraph">
<p>In the most general way the red-black tree construction algorithm is presented by the function `rbInsert(tree, key):</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_32_rbInsert.svg" target="_blank" rel="noopener"><img src="_images/Fig8_32_rbInsert.png" alt="Fig8 32 rbInsert" width="50%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.32. DRAKON-diagram of the function <code>rbInsert(tree, data)</code></p>
</div>
<div class="paragraph">
<p>When a new red node (a 'spring') is inserted, it is initially attached following the standard rules of a binary search tree. However, this simple act may create a structural instability, most commonly by placing two springs in a row, which violates the fundamental 'no two consecutive red nodes' rule.</p>
</div>
<div class="paragraph">
<p>To restore equilibrium, the algorithm examines the local tree-cluster formed by the new node x, its parent P, grandparent G, and uncle U. Each specific configuration (or nodeImage) represents a distinct state of the balancing automaton, dictating the necessary corrective measures: either 'hardening' the springs through recoloring or redistributing the weight via rotation. The complete logic of this balancing process is meticulously mapped out in the DRAKON-diagram shown in Figure 8.34.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_33_fixInsert.svg" target="_blank" rel="noopener"><img src="_images/Fig8_33_fixInsert.png" alt="Fig8 33 fixInsert" width="75%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.33. DRAKON-diagram of the Tree Balancing function <code>fixInsert(tree, data)</code></p>
</div>
<table id="table-8-3" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8.3 — Red-Black Tree Insertion Balancing: Automaton States and Strategies</caption>
<colgroup>
<col style="width: 12%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 28%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">Violation (Instability)</th>
<th class="tableblock halign-left valign-top">Key Condition</th>
<th class="tableblock halign-left valign-top">Balancing Strategy (Mechanical Fix)</th>
<th class="tableblock halign-left valign-top">Result / Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Case A</strong> (Red Uncle)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two consecutive "springs" (P and x are Red).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The uncle (U) is also a <strong>Red spring</strong>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Recolor (Shift Tension):</strong><br>
a. Harden Parent (P) and Uncle (U) into <strong>Black weights</strong>.<br>
b. Soften Grandparent (G) into a <strong>Red spring</strong>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The "tension" moves upward. Treat G as the new <strong>x</strong> and continue the fix-up toward the root.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Case B1</strong> (LL)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two consecutive "springs" (P and x are Red).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uncle (U) is a <strong>Black weight</strong> (or null). (LL: x is Left-Left child).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Recolor &amp; Rotate:</strong><br>
a. Harden P → black, soften G → red.<br>
b. <strong>Right Rotate</strong> around G to redistribute the weight.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Violation resolved locally. The former parent (P) becomes the new stable root of this subtree.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Case B2</strong> (RR)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two consecutive "springs" (P and x are Red).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uncle (U) is a <strong>Black weight</strong>. (RR: x is Right-Right child).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Recolor &amp; Rotate:</strong><br>
a. Harden P → black, soften G → red.<br>
b. <strong>Left Rotate</strong> around G to redistribute the weight.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Violation resolved locally. P becomes the new stable root.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Case B3</strong> (LR)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two consecutive "springs" (P and x are Red).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uncle (U) is a <strong>Black weight</strong>. (LR: x is Right child of Left parent).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Double Action:</strong><br>
1. <strong>Left Rotate</strong> around P to align the springs (converts LR to LL).<br>
2. Apply Case B1 fix (Recolor x/G and Right Rotate around G).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The double rotation realigns the "mechanical links." Node x becomes the new root of this subtree.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Case B4</strong> (RL)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two consecutive "springs" (P and x are Red).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uncle (U) is a <strong>Black weight</strong>. (RL: x is Left child of Right parent).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Double Action (Alignment and Redistribution):</strong><br>
1. <strong>First Rotation:</strong> Perform a <strong>right rotation</strong> around the parent (P). This aligns the two springs into a straight line, transforming the RL configuration into a predictable RR (Case B2).<br>
2. <strong>Second Rotation &amp; Recolor:</strong> With the springs now aligned, apply the Case B2 mechanical fix:<br>
   a. Harden the new local root (x) → <strong>black weight</strong>.<br>
   b. Soften the grandparent (G) → <strong>red spring</strong>.<br>
   c. Perform a <strong>left rotation</strong> around G to restore balance.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The double rotation reconfigures the mechanical links to stabilize the tree. The new node (x) becomes the stable root of this local subtree.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The DRAKON-diagram of the node rotation algorithms to the red and black tree cluster is shown in Figure 8.34a,b.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_34a_rotateLeft.svg" target="_blank" rel="noopener"><img src="_images/Fig8_34a_rotateLeft.png" alt="Fig8 34a rotateLeft" width="100%"></a>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>a) Left-rotation;</pre>
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_34b_rotateRight.svg" target="_blank" rel="noopener"><img src="_images/Fig8_34b_rotateRight.png" alt="Fig8 34b rotateRight" width="100%"></a>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>b) Right-rotation</pre>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.35. DRAKON-diagrams of node rotation algorithms used in red-black tree clusters.</p>
</div>
<div class="paragraph">
<p>The following videos demonstrate rebalancing during node insertion in Red-Black trees.</p>
</div>
<div class="paragraph text-center">
<p>Case 1 — Recoloring (Red Uncle)</p>
</div>
<video controls width="640">
  <source src="./_attachments/case1.mp4" type="video/mp4">
</video>
<div class="paragraph">
<p>Case 2 — Inner Rotation (LR Case)</p>
</div>
<video controls width="640">
  <source src="./_attachments/case2.mp4" type="video/mp4">
</video>
<div class="paragraph">
<p>Case 3 — Inner Rotation (RL Case)</p>
</div>
<video controls width="640">
  <source src="./_attachments/case3.mp4" type="video/mp4">
</video>
<div class="paragraph">
<p>Case 4 — Outer Rotation (LL Case)</p>
</div>
<video controls width="640">
  <source src="./_attachments/case4.mp4" type="video/mp4">
</video>
<div class="paragraph">
<p>Case 5 — Outer Rotation (RR Case)</p>
</div>
<video controls width="640">
  <source src="./_attachments/case5.mp4" type="video/mp4">
</video>
<div class="paragraph">
<p>Student Note: Experimenting with Red-Black Trees
You are encouraged to deepen your understanding of Red-Black Trees by conducting experiments using the dedicated online visualization and simulation tool,  [Red-Black Tree Visualizer](<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" class="bare">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a>). This interactive platform allows you to insert and delete nodes, observe the balancing operations in real-time, and visualize the tree structure dynamically. Engaging with this tool will enhance your comprehension of the complex balancing mechanisms inherent in Red-Black Trees.</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_4_2_deleting_a_node_restoring_the_weight_balance"><a class="anchor" href="#_8_4_2_deleting_a_node_restoring_the_weight_balance"></a>8.4.2. Deleting a Node: Restoring the Weight Balance</h4>
<div class="paragraph">
<p>Removing a node from a red-black tree is a sophisticated process because it involves not just structural changes, but also the preservation of the tree&#8217;s "gravitational" balance. However, by using our analogy of <strong>weights (black nodes)</strong> and <strong>springs (red nodes)</strong>, the logic becomes clear: the difficulty only arises when we lose a "weight."</p>
</div>
<div class="paragraph">
<p>The deletion process consists of three primary steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Identification and Search:</strong> As with a standard Binary Search Tree (BST), the algorithm first locates the target node (<strong>z</strong>) within the structure.</p>
</li>
<li>
<p><strong>Deletion and Replacement:</strong></p>
<div class="ulist">
<ul>
<li>
<p>If node <strong>z</strong> has zero or one child: We remove <strong>z</strong> and replace it with its non-NIL child (or a NIL node).</p>
</li>
<li>
<p>If node <strong>z</strong> has two children: We do not remove it directly. Instead, we find its <strong>inorder successor</strong> (the minimum node in its right subtree), swap their values, and then delete the successor. This ensures that the node being physically removed always has at most one child.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>The Color Impact (The Weight Factor):</strong>
The necessity for rebalancing depends entirely on the color of the node that was physically removed (let&#8217;s call it the "deleted component"):</p>
<div class="ulist">
<ul>
<li>
<p><strong>Case: Removing a Red Spring.</strong> If the deleted node was red, no rebalancing is needed. Why? Because a spring has no weight. Removing it does not change the "black height" of the branches. The equilibrium is preserved.</p>
</li>
<li>
<p><strong>Case: Removing a Black Weight.</strong> If the deleted node was black, we have a problem. We have removed a "brick" from one side of the scale. This branch is now "lighter" than the others, creating a <strong>Weight Deficit</strong>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>This deficit is what programmers call the <strong>"Double Black"</strong> problem. It is a signal to our balancing automaton that it must either:
a) Find a spare "spring" (red node) to harden into a weight.
b) Or redistribute the weights from neighboring branches to fill the gap.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><strong>Deleting a Red Node:</strong><br>
This is the simplest scenario. In our model, a red node is a "spring" that does not contribute to the black height (the total weight) of the branch. Simply removing it does not create a deficit or violate any RBT properties. The structural equilibrium remains perfectly intact.</p>
</li>
<li>
<p><strong>Deleting a Black Node:</strong><br>
This is the more complex case. Removing a black node is equivalent to removing a "weight" from a balanced scale. This creates a <strong>Weight Deficit</strong> (or "Double Black" state), violating the property that requires all paths to have the same black height. To fill this "void" and restore balance, the <strong>balancing state machine</strong> must perform an iterative process—either finding a spare "spring" to harden into a weight or shifting weight from a neighboring branch.</p>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="4">
<li>
<p><strong>Application of Corrective Adjustments:</strong><br>
Once a black node (a weight) is removed, the rebalancing procedure is triggered to restore the tree&#8217;s physical equilibrium. This process employs a sequence of recoloring and rotations, guided by the following principle:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>The "Double Black" Concept (The Weight Debt):</strong><br>
The node that occupies the position of the deleted black node is temporarily designated as <strong>"Double Black" (DB)</strong>. In our analogy, this is a <strong>Weight Debt</strong>—a conceptual void indicating that the path through this node is now "lighter" than required. The structure is under tension because Property 5 is violated.</p>
</div>
<div class="paragraph">
<p><strong>Corrective Cases (The Repair Logic):</strong><br>
The balancing automaton resolves this debt by analyzing the <strong>Sibling</strong> (or brother) of the DB node. Depending on the sibling&#8217;s color and the availability of "spare springs" (red children), the automaton executes specific fix-up cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Weight Transfer:</strong> Shifting a black weight from a neighboring branch.</p>
</li>
<li>
<p><strong>Spring Conversion:</strong> Hardening a red node into a black weight to fill the void.</p>
</li>
<li>
<p><strong>Debt Propagation:</strong> If the local cluster cannot provide the missing weight, the "debt" (DB status) is moved up toward the parent, making it the new focus of the balancing process until the deficit is cancelled at the root or resolved by a rotation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Simple Cases Where No Rebalancing is Needed</strong></p>
</div>
<div class="paragraph">
<p><code>Case A</code>: Deleting a Red Node with No Children
Since the node is red, its removal does not affect the black-height of any path.
The tree remains balanced without any additional operations.
Tree-Cluster: z:R, z←P; P:R|B;</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_35_Del_Case_A.png" alt="Fig8 35 Del Case A" width="30%">
</div>
</div>
<div class="paragraph">
<p><code>Case B</code>: Deleting a Black Node with One Red Child</p>
</div>
<div class="paragraph">
<p>The red child replaces the deleted black node and is repainted black.
This preserves the black-height on all paths through this subtree.
Tree-Cluster: z:B, z←P; z_L|z_R:R → Replace z with child (z_L|z_R); P:R|B</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_35_Del_Case_B.png" alt="Fig8 35 Del Case B" width="30%">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_complex_cases_managing_the_weight_debt_double_black"><a class="anchor" href="#_complex_cases_managing_the_weight_debt_double_black"></a>Complex Cases: Managing the "Weight Debt" (Double Black)</h4>
<div class="paragraph">
<p>To understand the balancing operations, we first establish the standard mechanical notation for our tree-cluster (Figure 8.36):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>z</strong>: The node to be deleted, or the <strong>"Double-Black"</strong> node (the focus of the weight debt).</p>
</li>
<li>
<p><strong>P</strong>: Parent of <strong>z</strong>.</p>
</li>
<li>
<p><strong>s</strong>: Sibling of <strong>z</strong>.</p>
</li>
<li>
<p><strong>s_L, s_R</strong>: Left and right children of the sibling <strong>s</strong> (the "nephews").</p>
</li>
<li>
<p><strong>y</strong>: The node that actually takes <strong>z</strong>'s place in the structure.</p>
</li>
</ul>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_36_Term_Cluster.png" alt="Fig8 36 Term Cluster" width="30%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.36. Tree node relationship</p>
</div>
<div class="paragraph">
<p>The deletion algorithm follows three key stages. When a black weight is removed, it leaves behind a "void" known as a <strong>Double Black (DB)</strong> node. Our goal is to "dissolve" this debt. If the local cluster cannot immediately provide a replacement weight, we use the <code>fixDoubleBlack(z)</code> function to resolve the crisis.</p>
</div>
<div class="sect4">
<h5 id="_case_1_the_sibling_s_is_a_red_spring"><a class="anchor" href="#_case_1_the_sibling_s_is_a_red_spring"></a>Case 1: The Sibling <strong>s</strong> is a Red Spring</h5>
<div class="paragraph">
<p>Case 1 is a "gateway" maneuver. A red sibling means that the "spare parts" we need are hidden deeper in the tree. We perform a rotation to bring a black weight closer to our debt point without changing the overall black height.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 28.5715%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tree-Cluster (BEFORE)</th>
<th class="tableblock halign-left valign-top">Violation (Instability)</th>
<th class="tableblock halign-left valign-top">Actions (Mechanical Fix)</th>
<th class="tableblock halign-left valign-top">Tree-Cluster (AFTER)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>z:DB, z←P; P:B; s:R, s→P; s_L:B; s_R:B</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red sibling blocks direct access to black weights. The branch is imbalanced.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. <strong>Recolor</strong> <strong>s</strong> to Black (harden it).<br>
  2. <strong>Recolor</strong> <strong>P</strong> to Red (soften it).<br>
  3. <strong>Left-rotate</strong> around <strong>P</strong>.<br>
  4. <strong>Re-analyze</strong> the new configuration (the sibling is now black).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">z:DB, z←P; P:R; s:B&#8230;&#8203; (Proceed to Cases 2, 3, or 4)</p></td>
</tr>
</tbody>
</table>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_37a_mindMap_deleteNode.png" alt="Fig8 37a mindMap deleteNode" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>a) Intellectual map</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_37b_deleteNode.svg" target="_blank" rel="noopener"><img src="_images/Fig8_37b_deleteNode.png" alt="Fig8 37b deleteNode" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>b) DRAKON-diagram of the general deletion algorithm (Figure 8.37)</p>
</div>
</div>
<div class="sect4">
<h5 id="_case_2_propagating_the_weight_debt"><a class="anchor" href="#_case_2_propagating_the_weight_debt"></a>Case 2: Propagating the "Weight Debt"</h5>
<div class="paragraph">
<p>If a black node is deleted, the path through its parent effectively loses one unit of weight. This <strong>Weight Deficit</strong> (Double Black) must "bubble up" the tree. If we cannot find a red spring to harden nearby, we move the debt to the parent, hoping to cancel it out at the root or find a resource higher up.</p>
</div>
</div>
<div class="sect4">
<h5 id="_case_3_resolving_the_debt_with_fixdoubleblackx"><a class="anchor" href="#_case_3_resolving_the_debt_with_fixdoubleblackx"></a>Case 3: Resolving the Debt with <code>fixDoubleBlack(x)</code></h5>
<div class="paragraph">
<p>The core of the repair logic lies in <code>fixDoubleBlack(x)</code>. The automaton&#8217;s strategy depends entirely on the "mechanical state" of the sibling <strong>s</strong> and its children (Figure 8.38).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_38a_fixDoubleBlack.png" alt="Fig8 38a fixDoubleBlack" width="50%">
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_38b_fixDoubleBlackStep.png" alt="Fig8 38b fixDoubleBlackStep" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.38. DRAKON-diagram of the "Double Black" resolution algorithm (Weight Debt Recovery).</p>
</div>
<div class="paragraph">
<p>The following table provides a complete guide to the cases handled by the balancing automaton during weight debt recovery. The key is to identify the mechanical configuration of the sibling (<strong>s</strong>) and the "nephews" to determine the correct sequence of weight redistribution.</p>
</div>
<table id="table-8-4" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8.4 — <code>fixDoubleBlack(x)</code> Resolution: Recovering the Weight Debt</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 30%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">Sibling (s) &amp; Nephews</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Actions (Mechanical Fix)</th>
<th class="tableblock halign-left valign-top">Outcome</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>1</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is Red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The sibling is a "spring". This is a <strong>gateway case</strong>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Harden <strong>s</strong> → black.<br>
  2. Soften <strong>parent</strong> → red.<br>
  3. Rotate (Left if <strong>x</strong> is left child).<br>
  4. Re-enter <code>fixDoubleBlack(x)</code> with the new black sibling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transforms the state into Case 2, 3, or 4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is Black, both nephews are Black</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The sibling branch is "heavy" and has no spare springs to lend.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Soften <strong>s</strong> → red (reducing sibling&#8217;s weight).<br>
  2. Move the <strong>Weight Debt</strong> upward: <code>x = x.parent</code>.<br>
  3. If the new <strong>x</strong> is a red spring, harden it to black (Debt Cancelled).<br>
  4. Otherwise, repeat the process.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The debt "bubbles up" toward the root.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is Black, at least one nephew is Red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The sibling has a "spare spring" that can be converted into weight.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>See Sub-cases 3a–3d below.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The debt is eliminated via rotations and weight redistribution.</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Sub-cases of Case 3 (Black Sibling with a Red Spare Spring):</caption>
<colgroup>
<col style="width: 12.5%;">
<col style="width: 37.5%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Sub-case</th>
<th class="tableblock halign-left valign-top">Configuration (assuming x is left child)</th>
<th class="tableblock halign-left valign-top">Actions (The Mechanical Adjustment)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3a</strong> (L-L)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is right child; <strong>s.right</strong> is a red spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Set color of <strong>s</strong> = color of <strong>parent</strong>.<br>
  2. Harden <strong>parent</strong> and <strong>s.right</strong> → black weights.<br>
  3. Left-rotate around <strong>parent</strong> to shift the weight to the debt-side.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3b</strong> (L-R)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is right child; <strong>s.left</strong> is a red spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Harden <strong>s.left</strong> → black; soften <strong>s</strong> → red.<br>
  2. Right-rotate around <strong>s</strong>.<br>
  3. This aligns the weights into an <strong>L-L</strong> configuration (Case 3a). Apply 3a.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3c</strong> (R-R)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is left child; <strong>s.left</strong> is a red spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Set color of <strong>s</strong> = color of <strong>parent</strong>.<br>
  2. Harden <strong>parent</strong> and <strong>s.left</strong> → black weights.<br>
  3. Right-rotate around <strong>parent</strong> to restore balance.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3d</strong> (R-L)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>s</strong> is left child; <strong>s.right</strong> is a red spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1. Harden <strong>s.right</strong> → black; soften <strong>s</strong> → red.<br>
  2. Left-rotate around <strong>s</strong>.<br>
  3. This aligns the weights into an <strong>R-R</strong> configuration (Case 3c). Apply 3c.</p></td>
</tr>
</tbody>
</table>
<table id="table-8-5" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8.5 — Summary of Deletion Scenarios (The Automaton Decision Matrix)</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 20%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">Mechanical State (nodeImage)</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Required Action</th>
<th class="tableblock halign-left valign-top">Fixup?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>1</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red leaf node (no children).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Removing a weightless spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple removal.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>2</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black weight with one red spring.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replacing weight with a spare part.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promote child, harden it to black.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>3</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black weight with black/null child.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Weight removed, no local spare parts.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Weight Debt arises.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Yes</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>4</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node with two children (direct successor).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Successor is the immediate neighbor.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Swap and transplant.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>5</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node with two children (indirect successor).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Successor is deep in the sub-tree.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complex rewire + transplant.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The process of replacing a node in a red-black tree using the <code>joinParentChild</code> function is illustrated in <strong>Figure 8.39</strong>.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_39_joinPC.png" alt="Fig8 39 joinPC" width="60%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.39. Replacing a node in a red-black tree (The <code>joinParentChild</code> operation)</p>
</div>
<div class="paragraph">
<p>The top diagram illustrates the replacement of node <strong>U</strong> (<code>9</code>) with subtree <strong>V</strong> (<code>7</code>) before calling <code>joinParentChild(tree, U, V)</code>. The bottom diagram shows the result: node <code>7</code> has taken the place of <code>9</code>, preserving the tree&#8217;s connectivity.</p>
</div>
<div class="paragraph">
<p>Let us examine the specific scenarios of node removal in more detail. In the first step, the node is removed following standard binary search tree rules. If either the removed node or its replacement is <strong>red</strong>, the structural equilibrium is easily maintained. In such cases, no further complex rebalancing is required (<strong>Figure 8.40</strong>).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_40_delRed.png" alt="Fig8 40 delRed" width="80%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.40. Deletion of a red node (Example: node 20)</p>
</div>
<div class="paragraph">
<p>However, if both the deleted node and its replacement are <strong>black</strong>, a "weight deficit" occurs, leading to the <strong>"double black node"</strong> state. To restore the tree&#8217;s properties, the balancing automaton must execute a series of corrective measures. The logic for this process is meticulously mapped in the <strong>DRAKON-diagrams</strong> shown in <strong>Figure 8.41</strong>.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_41_fixDoubleBlack.png" alt="Fig8 41 fixDoubleBlack" width="80%">
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_41b_fixDoubleBlackStep.svg" target="_blank" rel="noopener"><img src="_images/Fig8_41b_fixDoubleBlackStep.png" alt="Fig8 41b fixDoubleBlackStep" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.41. DRAKON-diagram of the "double black" resolution algorithm</p>
</div>
<div class="paragraph">
<p>The structural rules for replacement are as follows:
* If the replacement is a <strong>leaf node</strong> (no children): Replace the target node with a "NIL" leaf and color it black.
* If the replacement has <strong>one child</strong>: Replace the target node with its child and color that child black (hardening the spring).
* If the replacement has <strong>two children</strong>: Replace the node with its <strong>inorder successor</strong>, then delete the successor using the single-child method described above.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_43_delRed.png" alt="Fig8 43 delRed" width="80%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.43. Logic flow for structural correction</p>
</div>
<div class="paragraph">
<p>To fully restore the red-black properties after a replacement, the following final adjustments are performed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the deleted node was red, the tree&#8217;s balance remains undisturbed. If the replacement node is red, it must be <strong>repainted black</strong> to compensate for the lost weight.</p>
</li>
<li>
<p>If a "double black" state persists, perform rotations, recoloring, and the <strong>transfer of "blackness"</strong> (moving the weight deficit) up the tree until the equilibrium is restored.</p>
</li>
<li>
<p>Finally, ensure that the <strong>root</strong> of the tree remains black to maintain the global balancing constant.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s consider options for restoring the properties of red-black tree.
Enter the following notations: the node to be deleted is "x", the child
node of the deleted node is "y", and the sibling of the node to be
deleted is "s" (Figure 8.43).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_43_Term.jpg" alt="Fig8 43 Term" width="100%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.43. Tree node relationship</p>
</div>
<div class="paragraph">
<p>Option 1: If the child element (y) of the node to be deleted (x) is
coloured red, then after deletion it should be recoloured black, as a
result of which the number of black nodes will be restored (Figure
8.40).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_39_Term.jpg" alt="Fig8 39 Term" width="100%">
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<a class="image" href="_images/Fig8_42b_fixDoubleBlackStep.svg" target="_blank" rel="noopener"><img src="_images/Fig8_42b_fixDoubleBlackStep.png" alt="Fig8 42b fixDoubleBlackStep" width="100%"></a>
</div>
</div>
<div class="paragraph text-center">
<p>Fig. 8.40. Deleting and repainting the child of the node to be removed
(y)</p>
</div>
<div class="paragraph">
<p>Option 2: When the sib(s) of the node to be deleted (x) is coloured
black, and at least one of the descendants is red, then four different
combinations are possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Option 2(a): The brother(s) of the node to be deleted (x) is black. In
this case, the brother (s) is the left descendant of the parent (P), and
the left child of the brother is coloured red. This is the so-called
"left-left <em>configuration"</em>, in which the balance is achieved by the
right rotation, after which the color of the child should be replaced by
black (Fig. 8.41).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image44.jpg" alt="media/image44" width="427" height="165"></span></p>
</div>
<div class="paragraph">
<p>Figure. 8.41. Left-Left node delete configuration</p>
</div>
<div class="paragraph">
<p>Option 2(b): Mirror image of case 2(a). The "s" brother is his parent&#8217;s
right child, and his right child is the red child. The right-right
configuration performs a left-hand rotation. The child node is then
changed to black. As a result, the black node counter property is
restored (Fig. 8.42).</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image45.jpg" alt="media/image45" width="412" height="123"></span></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Figure 8.42. Right-Right configuration of node deletion</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Option 2 (c). The brother (s) of the remote node (y) is black. The
brother(s) is the left offspring of his parent, and his right child is
red. This is a left-to-right configuration, so a left rotation is
performed followed by a right rotation. The child node is coloured black
(Figure 8.43):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image46.jpg" alt="media/image46" width="670" height="121"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.43. Left-Right node delete configuration</p>
</div>
<div class="paragraph">
<p>Option 2(d): The brother (s) of the remote node (y) is coloured black.
The brother (s) is the right child of his parent (P) and his left child
is the red child. A right-left rotation is then performed, followed by a
left-hand rotation. The color of the child node changes to black (Fig.
8.44).<span class="image unresolved"><img src="media/image47.jpg" alt="media/image47" width="670" height="121"></span> Figure
8.44. Right-Left node delete configuration</p>
</div>
<div class="paragraph">
<p>Option H: If the node (y) to be removed and its brother(s) are coloured
black and both of its descendants are missing, i.e. black by definition,
then you need to recolour the children red and recursively add black to
the parent. If the parent was red, then it became black. If the parent
was black, it would become double black. If the parent is the root, then
it remains black. For example, below is a case where the node (y) to be
deleted and its brother (s) are black (Figure 8.45):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image48.png" alt="media/image48" width="477" height="176"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.45 The Process of rebuilding a tree with two black nodes (y)
and (s)</p>
</div>
<div class="paragraph">
<p>Option 4: If the sib(s) of the node to be removed (y) is coloured red,
then a rotation is performed to achieve the balance of the tree. The
sister nodes are then repainted. For example, consider the following
option (Fig. 8.46):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image49.jpg" alt="media/image49" width="670" height="169"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.46. The process of rebuilding a tree with two nodes (y) and (s)
of different colours</p>
</div>
<div class="paragraph">
<p>Conclusion</p>
</div>
<div class="paragraph">
<p>Trees are one of the most important data structures in computer science,
used to represent hierarchical relationships and organize data. They
provide efficient search, insert, and delete operations, making them
ideal for use in a variety of applications.</p>
</div>
<div class="paragraph">
<p>AVL trees, named after their creators Adelsky-Velsky and Landis, are
balanced binary search trees. They provide fast search, insertion, and
deletion by keeping the height of the tree logarithmic relative to the
number of nodes. However, AVL trees require additional insertion and
deletion operations to maintain balance, which can be a disadvantage in
some applications.</p>
</div>
<div class="paragraph">
<p>Red-black trees are another type of balanced binary search trees. They
provide efficient search, insert, and delete operations, but can be more
difficult to implement because of the additional properties they must
support. They are widely used in many standard libraries.</p>
</div>
<div class="paragraph">
<p>The choice of a specific tree type depends on the specific requirements
of the application. AVL trees are generally preferred when frequent
searches are the most important operations, as they provide a more
stringent balance than red-black trees. On the other hand, red-and-black
trees can be more effective with frequent insertions and removals, as
they require fewer turns to maintain balance.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to remember that both types of trees require additional
memory to store balance information, and both can be difficult to
implement. In some cases, other data structures, such as hash tables or
B-trees, may be more appropriate. However, despite these challenges,
trees continue to play a central role in computer science and are a key
tool for any programmer.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 99%;">
<colgroup>
<col style="width: 28%;">
<col style="width: 5%;">
<col style="width: 8%;">
<col style="width: 12%;">
<col style="width: 6%;">
<col style="width: 8%;">
<col style="width: 8%;">
<col style="width: 8%;">
<col style="width: 9%;">
<col style="width: 8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">Tree type</th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">AVL</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Red-Black</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time Complexity:</p>
</div>
<div class="paragraph">
<p>Insert, Find, Delete</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(sqrt(N))</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Space Complexity</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Iterative</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Recursive</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(H)=O(sqrt(N))</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
