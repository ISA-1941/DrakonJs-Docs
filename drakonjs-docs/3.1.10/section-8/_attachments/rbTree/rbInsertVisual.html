<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RB Tree Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Font and main container settings */
        :root {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure SVG container takes up space */
        #tree-svg-container {
            min-height: 400px;
            overflow-x: auto; /* Allows scrolling for large trees */
        }
        .node-circle {
            transition: r 0.3s, fill 0.3s, stroke 0.3s;
        }
        .node-text {
            user-select: none;
            pointer-events: none;
        }
        .black-node { fill: #374151; stroke: #1F2937; }
        .red-node { fill: #EF4444; stroke: #B91C1C; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 p-4 sm:p-6">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold mb-4 text-gray-800">Interactive Red-Black Tree Visualizer</h1>
        <p class="text-sm mb-4 text-gray-600">Enter a number to insert and observe the automatic balancing and recoloring of nodes.</p>

        <!-- Insertion Controls -->
        <div class="flex flex-col sm:flex-row gap-3 p-4 bg-white shadow-lg rounded-lg mb-6 items-center">
            <input 
                type="number" 
                id="keyInput" 
                placeholder="Enter a Key" 
                class="w-full sm:w-40 p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500"
                min="1"
                max="999"
            >
            <button 
                id="insertBtn" 
                class="w-full sm:w-auto px-4 py-2 bg-red-600 text-white font-semibold rounded-md shadow-md hover:bg-red-700 transition duration-150 ease-in-out disabled:bg-gray-400"
            >
                Insert Node
            </button>
            <button 
                id="resetBtn" 
                class="w-full sm:w-auto px-4 py-2 bg-gray-500 text-white font-semibold rounded-md shadow-md hover:bg-gray-600 transition duration-150 ease-in-out"
            >
                Reset Tree
            </button>
        </div>

        <!-- Tree Visualization Container -->
        <div id="tree-svg-container" class="bg-white p-4 rounded-lg shadow-lg border border-gray-200">
            <svg id="tree-svg" width="100%" height="400" viewBox="0 0 800 400" preserveAspectRatio="xMinYMin meet"></svg>
        </div>

        <!-- Status and Logging -->
        <div id="status" class="mt-4 p-3 text-sm bg-blue-100 text-blue-800 border-l-4 border-blue-500 rounded hidden">
            Awaiting input...
        </div>
    </div>

    <script>
        // --- 1. Red-Black Tree Logic (Functional/Procedural style, compatible with DRAKON) ---

        const NODE_RADIUS = 15; // Node radius for visualization
        const H_SPACING = 50;  // Default horizontal space between nodes
        const V_SPACING = 80;  // Vertical space between levels

        /**
         * Node factory function. Creates a new node object.
         * @param {number|null} key - The key value.
         * @param {string} color - 'R' (Red) or 'B' (Black).
         * @param {object|null} left - Left child node.
         * @param {object|null} right - Right child node.
         * @param {object|null} parent - Parent node.
         * @returns {object} The new node object.
         */
        function makeNode(key = null, color = "B", left = null, right = null, parent = null) {
            return { key, color, left, right, parent, x: 0, y: 0, visualKey: key }; 
        }

        /**
         * Tree factory function. Creates the tree structure with a sentinel nullNode.
         * @returns {object} The tree structure containing root and nullNode.
         */
        function makeRBTree() {
            // The sentinel NIL node is always black
            const nullNode = makeNode(null, "B", null, null, null);
            nullNode.left = nullNode;
            nullNode.right = nullNode;
            nullNode.parent = nullNode;
            nullNode.visualKey = "NIL"; // Visual label for the sentinel
            
            return { root: nullNode, nullNode };
        }

        // --- RBT Helper Functions (All functions accept state explicitly) ---

        /**
         * Inserts a key using standard BST logic, returns the newly created Red node.
         * @param {object} tree - The tree structure (containing root and nullNode).
         * @param {number} key - The key to insert.
         * @returns {object} The newly created node.
         */
        function bstInsert(tree, key) {
            let y = tree.nullNode; // Trailing pointer (parent of new node)
            let x = tree.root;     // Current node

            while (x !== tree.nullNode) {
                y = x;
                if (key < x.key) x = x.left;
                else x = x.right;
            }

            // Create new node (always starts Red)
            const newNode = makeNode(key, "R", tree.nullNode, tree.nullNode, y);
            
            // Link new node into the tree
            if (y === tree.nullNode) {
                tree.root = newNode; // Tree was empty
            } else if (key < y.key) {
                y.left = newNode;
            } else {
                y.right = newNode;
            }

            return newNode;
        }

        /**
         * Performs a Left Rotation around node x.
         * @param {object} tree - The tree structure.
         * @param {object} x - The pivot node (must have a right child).
         */
        function rotateLeft(tree, x) {
            const y = x.right; // y is the node that moves up
            x.right = y.left;
            if (y.left !== tree.nullNode) y.left.parent = x;
            y.parent = x.parent;
            
            // Adjust root or parent's child pointer
            if (x.parent === tree.nullNode) tree.root = y;
            else if (x === x.parent.left) x.parent.left = y;
            else x.parent.right = y;
            
            y.left = x;
            x.parent = y;
        }

        /**
         * Performs a Right Rotation around node x.
         * @param {object} tree - The tree structure.
         * @param {object} x - The pivot node (must have a left child).
         */
        function rotateRight(tree, x) {
            const y = x.left; // y is the node that moves up
            x.left = y.right;
            if (y.right !== tree.nullNode) y.right.parent = x;
            y.parent = x.parent;
            
            // Adjust root or parent's child pointer
            if (x.parent === tree.nullNode) tree.root = y;
            else if (x === x.parent.right) x.parent.right = y;
            else x.parent.left = y;
            
            y.right = x;
            x.parent = y;
        }

        // Fix case 1: Parent is black (no violation)
        function fixCase1(tree, node) { /* Do nothing */ return tree; }

        // Fix case 2: Parent and Uncle are Red (Recolor)
        function fixCase2(tree, node) {
            const parent = node.parent;
            const grand = parent.parent;
            const uncle = (parent === grand.left) ? grand.right : grand.left;

            parent.color = 'B';
            uncle.color = 'B';
            grand.color = 'R';

            // Recurse up the tree at the grandparent
            return fixInsert(tree, grand);
        }

        // Fix case 3: Parent is Red, Uncle is Black (Rotation and Recolor)
        function fixCase3(tree, node) {
            let parent = node.parent;
            let grand = parent.parent;

            // Inner case conversion (e.g., LR -> LL or RL -> RR)
            if (node === parent.right && parent === grand.left) {
                rotateLeft(tree, parent);
                node = node.left; 
            } else if (node === parent.left && parent === grand.right) {
                rotateRight(tree, parent);
                node = node.right; 
            }

            // Recalculate parent/grandparent after potential inner rotation
            parent = node.parent;
            grand = parent.parent;

            parent.color = 'B';
            grand.color = 'R';

            // Outer case rotation
            if (node === parent.left && parent === grand.left) {
                rotateRight(tree, grand);
            } else {
                rotateLeft(tree, grand);
            }

            return tree;
        }

        /**
         * Fixes Red-Black tree properties after insertion.
         * @param {object} tree - The tree structure.
         * @param {object} node - The newly inserted node.
         */
        function fixInsert(tree, node) {
            const parent = node.parent;

            // Case 0: Node is the root
            if (parent === tree.nullNode) {
                tree.root.color = 'B';
                return tree;
            }

            // Case 1: Parent is Black (No violation)
            if (parent.color === 'B') {
                return fixCase1(tree, node);
            }
            
            // If parent is Red, we must have a grandparent
            const grand = parent.parent;
            const uncle = (parent === grand.left) ? grand.right : grand.left;

            // Case 2: Parent and Uncle are Red (Recolor and repeat)
            if (uncle.color === 'R') {
                return fixCase2(tree, node);
            }

            // Case 3: Parent is Red, Uncle is Black (Rotation and Recolor)
            return fixCase3(tree, node);
        }

        /**
         * Main insert function.
         * @param {object} tree - The tree structure.
         * @param {number} key - The key to insert.
         */
        function insert(tree, key) {
            const node = bstInsert(tree, key);
            fixInsert(tree, node);
            // Ensure root is always black
            tree.root.color = 'B';
            return tree;
        }


        // --- 2. SVG Visualization Logic (Remains the same) ---

        let rbtree;
        let x_counter; 

        const svg = document.getElementById('tree-svg');
        const container = document.getElementById('tree-svg-container');
        const keyInput = document.getElementById('keyInput');
        const insertBtn = document.getElementById('insertBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statusDiv = document.getElementById('status');
        
        // Function to calculate (X, Y) positions for all nodes
        function calculatePositions(node, depth) {
            if (node === rbtree.nullNode) return;

            // Set Y position
            node.y = depth * V_SPACING + NODE_RADIUS + 20;

            // 1. Process left subtree first
            calculatePositions(node.left, depth + 1);

            // 2. Set X position (In-order traversal prevents overlap)
            node.x = x_counter * H_SPACING + NODE_RADIUS;
            x_counter++;

            // 3. Process right subtree
            calculatePositions(node.right, depth + 1);
        }

        // Function to render the tree in SVG
        function renderTree() {
            // Clear SVG
            svg.innerHTML = '';
            
            if (rbtree.root === rbtree.nullNode) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '50%');
                text.setAttribute('y', '50%');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#9CA3AF');
                text.textContent = 'Tree is empty';
                svg.appendChild(text);
                return;
            }
            
            x_counter = 1; // Reset horizontal counter
            calculatePositions(rbtree.root, 0);

            // Determine necessary SVG dimensions
            let maxX = 0;
            let maxDepth = 0;
            
            // Find max X and max Y (depth) to adjust the viewBox
            const findMax = (node) => {
                if (node === rbtree.nullNode) return;
                maxX = Math.max(maxX, node.x);
                maxDepth = Math.max(maxDepth, node.y);
                findMax(node.left);
                findMax(node.right);
            };
            findMax(rbtree.root);
            
            const newWidth = maxX + H_SPACING + NODE_RADIUS;
            const newHeight = maxDepth + V_SPACING;

            // Update SVG dimensions/viewBox to fit the content dynamically
            svg.setAttribute('width', newWidth);
            svg.setAttribute('height', newHeight);
            svg.setAttribute('viewBox', `0 0 ${newWidth} ${newHeight}`);
            
            // Recursive function to draw lines and nodes
            const drawNode = (node) => {
                if (node === rbtree.nullNode) return;

                // 1. Draw lines to children
                if (node.left !== rbtree.nullNode) {
                    drawLine(node, node.left);
                }
                if (node.right !== rbtree.nullNode) {
                    drawLine(node, node.right);
                }

                // 2. Draw the node itself
                drawCircle(node);

                // Recursive call
                drawNode(node.left);
                drawNode(node.right);
            };

            drawNode(rbtree.root);
        }

        function drawLine(parent, child) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', parent.x);
            line.setAttribute('y1', parent.y);
            line.setAttribute('x2', child.x);
            line.setAttribute('y2', child.y);
            line.setAttribute('stroke', '#6B7280');
            line.setAttribute('stroke-width', 2);
            svg.appendChild(line);
        }

        function drawCircle(node) {
            // Group element for positioning the node and its text together
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${node.x}, ${node.y})`);

            // Node circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', NODE_RADIUS);
            circle.setAttribute('class', `node-circle ${node.color === 'R' ? 'red-node' : 'black-node'}`);
            circle.setAttribute('stroke-width', 2);
            g.appendChild(circle);

            // Node text/key
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'central');
            text.setAttribute('font-size', '12px');
            text.setAttribute('fill', node.color === 'R' ? 'white' : 'white');
            text.setAttribute('class', 'node-text font-medium');
            text.textContent = node.visualKey === "NIL" ? 'NIL' : node.visualKey;
            g.appendChild(text);

            svg.appendChild(g);
        }

        // --- 3. Event Handlers ---

        function updateStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
            if (isError) {
                statusDiv.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
            } else {
                statusDiv.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500');
            }
            // Hide after 5 seconds
            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }

        function handleInsert() {
            const key = parseInt(keyInput.value);

            if (isNaN(key) || key <= 0) {
                updateStatus("Please enter a valid positive number.", true);
                return;
            }
            
            // Check for duplicates
            let currentNode = rbtree.root;
            while(currentNode !== rbtree.nullNode) {
                if (currentNode.key === key) {
                     updateStatus(`Key ${key} already exists in the tree. Duplicates are not allowed.`, true);
                     return;
                }
                currentNode = key < currentNode.key ? currentNode.left : currentNode.right;
            }

            try {
                insert(rbtree, key);
                renderTree();
                updateStatus(`Node with key ${key} successfully inserted and tree balanced.`, false);
                keyInput.value = '';
            } catch (error) {
                console.error("Insertion error:", error);
                updateStatus("An error occurred during insertion. Please reset the tree.", true);
            }
        }

        function handleReset() {
            rbtree = makeRBTree();
            renderTree();
            updateStatus("The RB Tree has been reset. Start inserting keys.", false);
            keyInput.value = '';
        }

        // Initialization on load
        document.addEventListener('DOMContentLoaded', () => {
            handleReset(); // Reset and initial render of an empty tree
            
            insertBtn.addEventListener('click', handleInsert);
            resetBtn.addEventListener('click', handleReset);
            
            keyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleInsert();
                }
            });
        });
    </script>
</body>
</html>