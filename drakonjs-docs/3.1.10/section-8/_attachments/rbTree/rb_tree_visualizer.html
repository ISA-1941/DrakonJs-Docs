<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red-Black Tree Visualizer</title>
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Font and main container settings */
        :root {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure SVG container takes up space */
        #tree-svg-container {
            min-height: 400px;
            overflow-x: auto; /* Allows scrolling for large trees */
        }
        .node-circle {
            transition: r 0.3s, fill 0.3s, stroke 0.3s;
        }
        .node-text {
            user-select: none;
            pointer-events: none;
        }
        .black-node { fill: #374151; stroke: #1F2937; }
        .red-node { fill: #EF4444; stroke: #B91C1C; }

        /* FIXED: Simple explicit style for controls container for resilience and visibility */
        #controls-container {
            padding: 1rem;
            /* Using a high-contrast background to ensure controls are visible */
            background-color: #fef3c7; /* Light Yellow/Cream */
            border: 2px solid #f59e0b; /* Orange border */
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
            display: flex; /* Ensure flex behavior */
            gap: 12px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            align-items: center;
        }
        /* Explicit width for input for better visibility */
        #keyInput {
            min-width: 150px;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 p-4 sm:p-6">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold mb-4 text-gray-800">Interactive Red-Black Tree Visualizer</h1>
        <p class="text-sm mb-4 text-gray-600">Enter a number to insert and observe the automatic balancing and recoloring of nodes.</p>

        <!-- Insertion Controls - With explicit ID for robustness -->
        <div id="controls-container" class="shadow-lg">
            <input 
                type="number" 
                id="keyInput" 
                placeholder="Enter a Key" 
                class="flex-grow p-2 border border-gray-300 rounded-md focus:ring-red-500 focus:border-red-500"
                min="1"
                max="999"
            >
            <button 
                id="insertBtn" 
                class="px-4 py-2 bg-red-600 text-white font-semibold rounded-md shadow-md hover:bg-red-700 transition duration-150 ease-in-out disabled:bg-gray-400"
            >
                Insert Node
            </button>
            <button 
                id="resetBtn" 
                class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-md shadow-md hover:bg-gray-600 transition duration-150 ease-in-out"
            >
                Reset Tree
            </button>
        </div>

        <!-- Tree Visualization Container -->
        <div id="tree-svg-container" class="bg-white p-4 rounded-lg shadow-lg border border-gray-200">
            <svg id="tree-svg" width="100%" height="400" viewBox="0 0 800 400" preserveAspectRatio="xMinYMin meet"></svg>
        </div>

        <!-- Status and Logging -->
        <div id="status" class="mt-4 p-3 text-sm bg-blue-100 text-blue-800 border-l-4 border-blue-500 rounded hidden">
            Awaiting input...
        </div>
    </div>

    <script>
        // --- 1. Red-Black Tree Logic (Functional/Procedural style) ---

        // Diagnostic message: Checking if the script loads
        console.log("RB Tree Visualizer Script Loaded.");

        const NODE_RADIUS = 15; // Node radius for visualization
        const H_SPACING = 50;  // Default horizontal space between nodes
        const V_SPACING = 80;  // Vertical space between levels

        function makeNode(key = null, color = "B", left = null, right = null, parent = null) {
            return { key, color, left, right, parent, x: 0, y: 0, visualKey: key }; 
        }

        function makeRBTree() {
            const nullNode = makeNode(null, "B", null, null, null);
            nullNode.left = nullNode;
            nullNode.right = nullNode;
            nullNode.parent = nullNode;
            nullNode.visualKey = "NIL"; 
            
            return { root: nullNode, nullNode };
        }

        function bstInsert(tree, key) {
            let y = tree.nullNode;
            let x = tree.root;

            while (x !== tree.nullNode) {
                y = x;
                if (key < x.key) x = x.left;
                else x = x.right;
            }

            const newNode = makeNode(key, "R", tree.nullNode, tree.nullNode, y);
            
            if (y === tree.nullNode) {
                tree.root = newNode;
            } else if (key < y.key) {
                y.left = newNode;
            } else {
                y.right = newNode;
            }

            return newNode;
        }

        function rotateLeft(tree, x) {
            const y = x.right;
            x.right = y.left;
            if (y.left !== tree.nullNode) y.left.parent = x;
            y.parent = x.parent;
            
            if (x.parent === tree.nullNode) tree.root = y;
            else if (x === x.parent.left) x.parent.left = y;
            else x.parent.right = y;
            
            y.left = x;
            x.parent = y;
        }

        function rotateRight(tree, x) {
            const y = x.left;
            x.left = y.right;
            if (y.right !== tree.nullNode) y.right.parent = x;
            y.parent = x.parent;
            
            if (x.parent === tree.nullNode) tree.root = y;
            else if (x === x.parent.right) x.parent.right = y;
            else x.parent.left = y;
            
            y.right = x;
            x.parent = y;
        }

        function fixCase1(tree, node) { return tree; }

        function fixCase2(tree, node) {
            const parent = node.parent;
            const grand = parent.parent;
            const uncle = (parent === grand.left) ? grand.right : grand.left;

            parent.color = 'B';
            uncle.color = 'B';
            grand.color = 'R';

            return fixInsert(tree, grand);
        }

        function fixCase3(tree, node) {
            let parent = node.parent;
            let grand = parent.parent;

            if (node === parent.right && parent === grand.left) {
                rotateLeft(tree, parent);
                node = node.left; 
            } else if (node === parent.left && parent === grand.right) {
                rotateRight(tree, parent);
                node = node.right; 
            }

            parent = node.parent;
            grand = parent.parent;

            parent.color = 'B';
            grand.color = 'R';

            if (node === parent.left && parent === grand.left) {
                rotateRight(tree, grand);
            } else {
                rotateLeft(tree, grand);
            }

            return tree;
        }

        function fixInsert(tree, node) {
            const parent = node.parent;

            if (parent === tree.nullNode) {
                tree.root.color = 'B';
                return tree;
            }

            if (parent.color === 'B') {
                return fixCase1(tree, node);
            }
            
            const grand = parent.parent;
            const uncle = (parent === grand.left) ? grand.right : grand.left;

            if (uncle.color === 'R') {
                return fixCase2(tree, node);
            }

            return fixCase3(tree, node);
        }

        function insert(tree, key) {
            const node = bstInsert(tree, key);
            fixInsert(tree, node);
            tree.root.color = 'B';
            return tree;
        }


        // --- 2. SVG Visualization Logic ---

        let rbtree;
        let x_counter; 

        const svg = document.getElementById('tree-svg');
        const keyInput = document.getElementById('keyInput');
        const insertBtn = document.getElementById('insertBtn');
        const resetBtn = document.getElementById('resetBtn');
        const statusDiv = document.getElementById('status');
        
        function calculatePositions(node, depth) {
            if (node === rbtree.nullNode) return;
            node.y = depth * V_SPACING + NODE_RADIUS + 20;
            calculatePositions(node.left, depth + 1);
            node.x = x_counter * H_SPACING + NODE_RADIUS;
            x_counter++;
            calculatePositions(node.right, depth + 1);
        }

        function renderTree() {
            svg.innerHTML = '';
            
            if (rbtree.root === rbtree.nullNode) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '50%');
                text.setAttribute('y', '50%');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#9CA3AF');
                text.textContent = 'Tree is empty';
                svg.appendChild(text);
                return;
            }
            
            x_counter = 1;
            calculatePositions(rbtree.root, 0);

            let maxX = 0;
            let maxDepth = 0;
            
            const findMax = (node) => {
                if (node === rbtree.nullNode) return;
                maxX = Math.max(maxX, node.x);
                maxDepth = Math.max(maxDepth, node.y);
                findMax(node.left);
                findMax(node.right);
            };
            findMax(rbtree.root);
            
            const newWidth = maxX + H_SPACING + NODE_RADIUS;
            const newHeight = maxDepth + V_SPACING;

            svg.setAttribute('width', newWidth);
            svg.setAttribute('height', newHeight);
            svg.setAttribute('viewBox', `0 0 ${newWidth} ${newHeight}`);
            
            const drawNode = (node) => {
                if (node === rbtree.nullNode) return;

                if (node.left !== rbtree.nullNode) {
                    drawLine(node, node.left);
                }
                if (node.right !== rbtree.nullNode) {
                    drawLine(node, node.right);
                }

                drawCircle(node);

                drawNode(node.left);
                drawNode(node.right);
            };

            drawNode(rbtree.root);
        }

        function drawLine(parent, child) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', parent.x);
            line.setAttribute('y1', parent.y);
            line.setAttribute('x2', child.x);
            line.setAttribute('y2', child.y);
            line.setAttribute('stroke', '#6B7280');
            line.setAttribute('stroke-width', 2);
            svg.appendChild(line);
        }

        function drawCircle(node) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${node.x}, ${node.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('r', NODE_RADIUS);
            circle.setAttribute('class', `node-circle ${node.color === 'R' ? 'red-node' : 'black-node'}`);
            circle.setAttribute('stroke-width', 2);
            g.appendChild(circle);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'central');
            text.setAttribute('font-size', '12px');
            text.setAttribute('fill', node.color === 'R' ? 'white' : 'white');
            text.setAttribute('class', 'node-text font-medium');
            text.textContent = node.visualKey === "NIL" ? 'NIL' : node.visualKey;
            g.appendChild(text);

            svg.appendChild(g);
        }

        // --- 3. Event Handlers ---

        function updateStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'border-red-500', 'bg-blue-100', 'text-blue-800', 'border-blue-500');
            if (isError) {
                statusDiv.classList.add('bg-red-100', 'text-red-800', 'border-red-500');
            } else {
                statusDiv.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-500');
            }
            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }

        function handleInsert() {
            const key = parseInt(keyInput.value);

            if (isNaN(key) || key <= 0) {
                updateStatus("Please enter a valid positive number.", true);
                return;
            }
            
            let currentNode = rbtree.root;
            while(currentNode !== rbtree.nullNode) {
                if (currentNode.key === key) {
                     updateStatus(`Key ${key} already exists. Duplicates are not allowed.`, true);
                     return;
                }
                currentNode = key < currentNode.key ? currentNode.left : currentNode.right;
            }

            try {
                insert(rbtree, key);
                renderTree();
                updateStatus(`Node with key ${key} successfully inserted and tree balanced.`, false);
                keyInput.value = '';
            } catch (error) {
                console.error("Insertion error:", error);
                updateStatus("An error occurred during insertion. Please reset the tree.", true);
            }
        }

        function handleReset() {
            rbtree = makeRBTree();
            renderTree();
            updateStatus("RB Tree has been reset. Start inserting keys.", false);
            keyInput.value = '';
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Diagnostic message: Checking that DOMContentLoaded fired
            console.log("RB Tree Visualizer DOMContentLoaded.");
            handleReset();
            
            insertBtn.addEventListener('click', handleInsert);
            resetBtn.addEventListener('click', handleReset);
            
            keyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleInsert();
                }
            });
        });
    </script>
</body>
</html>