<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Drakon.js Docs</title>
    <link rel="canonical" href="https://ISA-1941.github.io/DrakonJs-Docs/drakonjs-docs/3.1.10/section-8/Section%208_4.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://ISA-1941.github.io/DrakonJs-Docs">Drakon.js Docs</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="drakonjs-docs" data-version="3.1.10">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">drakonjs-docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../index.html">Introduction</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Abstract Data Types</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-1/section-1.html">ADT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">JavaScript View</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-2/section-2.html">JavaScript</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Implementation base types</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-3/section-3.html">Implementation base types</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Language Drakon</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-4/section-4.html">Visual Language Drakon</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Complexity of algorithms</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-5/section-5.html">Complexity problems</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Basic search  algorithms</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-6/section-6.html">Base Search Algorithms</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Base algorithms sorting</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../section-7/section-7.html">Base Sorting Algorithms</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">drakonjs-docs</span>
    <span class="version">3.1.10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">drakonjs-docs</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">3.1.10</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<div class="edit-this-page"><a href="https://github.com/ISA-1941/DrakonJs-Docs/edit/main/docs-src/modules/section-8/pages/Section%208_4.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect2">
<h3 id="_8_4_red_black_trees"><a class="anchor" href="#_8_4_red_black_trees"></a>8.4 Red-black trees</h3>
<div class="sect3">
<h4 id="_8_4_1_properties_of_red_black_trees"><a class="anchor" href="#_8_4_1_properties_of_red_black_trees"></a>8.4.1. Properties of red-black trees</h4>
<div class="paragraph">
<p>A red-black tree is a variant of a self-balancing binary search tree in
which the nodes are placed according to a certain rule and coloured red
or black (Figure 8.29)</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_29_redblackTree.png" alt="Fig8 29 redblackTree" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.29. Red-Black Tree</p>
</div>
<div class="paragraph">
<p>The nodes containing data (in this case, integers) are internal. In
addition, red-black trees contain imaginary, "null" nodes associated
with tree leaves (Null - in Figure 8.29). Red-black trees satisfy all
the properties of a binary search tree and must have the following
properties:</p>
</div>
<div class="paragraph">
<p>1. Each node is coloured red or black.</p>
</div>
<div class="paragraph">
<p>2. The root of the tree is always black.</p>
</div>
<div class="paragraph">
<p>3. All leaves are black (Null).</p>
</div>
<div class="paragraph">
<p>4. Both descendants of the red node are black, i.e. there cannot
be consecutive red nodes.</p>
</div>
<div class="paragraph">
<p>5. All simple paths from the node to the descending leaves
contain the same number of black nodes.</p>
</div>
<div class="paragraph">
<p>Unlike AVL trees, where balance is achieved by balancing the heights of
the left and right subtrees, red-black balance is achieved by the
properties mentioned above. Adding or removing a node from the red-black
tree can disrupt the red-black tree properties, and restoring balance is
achieved by two operations: repainting the nodes and/or rebuilding the
whole tree or its subtrees using specific rotations.The most important
of these properties are properties 4 and 5.</p>
</div>
<div class="paragraph">
<p>Property 4 dictates a critical aspect of red-black trees: the path from any given node to its deepest descendant must contain an equal number of red and black nodes. This isn&#8217;t just an arbitrary rule; it&#8217;s a fundamental mechanism for maintaining balance.</p>
</div>
<div class="paragraph">
<p>Property 5 builds on this by enforcing a uniform "black-height" for all paths from any node to its leaf descendants. Regardless of the specific path taken, the count of black nodes remains constant.</p>
</div>
<div class="paragraph">
<p>Black height is an important term used for red-black trees. This is the number of black nodes on any single path from node x (not including it) to the leaf. The black height of any node x is represented as a logarithm of the number of nodes in the tree. In particular, if in each branch from the root to the leaves the same number of black nodes, then the height of the tree will be equal to a logarithm of the number of nodes. This property allows you to quickly perform basic operations of the search tree, such as adding, removing and searching for a node.</p>
</div>
<div class="paragraph">
<p>To perform the above operations at the program level, a red-black tree is first created, for which two user types - node and RBTree are declared:
Node includes the following fields: <code>data</code> - node numeric value,  <code>colour</code> - node colour type bool: <code>red node</code> - TRUE; <code>black node</code> - false, <code>left</code>, <code>right</code> and <code>parent</code> nodes. In turn RBTree structure represents the reference type variable, that store objects containing not the "value" itself but a reference to the memory area where this object is stored (Fig. 8.30).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_30_createNodeTree.png" alt="Fig8 30 createNodeTree" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.30. Node Properties and the createNode Factory Function</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Turn Name</th>
<th class="tableblock halign-left valign-top">X is&#8230;&#8203;</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Left Rotation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Right child of an unbalanced node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promotes the right child <code>y</code> upward; the current node <code>x</code> becomes the left child of <code>y</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Right Rotation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Left child of an unbalanced node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promotes the left child <code>y</code> upward; the current node <code>x</code> becomes the right child of <code>y</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Left-Right Rotation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Right child of left subtree</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performs a left rotation on <code>x.left</code>, then a right rotation on <code>x</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Right-Left Rotation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Left child of right subtree</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performs a right rotation on <code>x.right</code>, then a left rotation on <code>x</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The DRAKON-diagrams of rotate functions are presented on Figure 8.31a,b.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_30_rotateLeft.jpg" alt="Fig8 30 rotateLeft" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.31. Rotate function DRAKON-diagrams (a - rotateLeft; b - rotate right)</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_4_2_inserting_a_new_node_and_the_balancing_process"><a class="anchor" href="#_8_4_2_inserting_a_new_node_and_the_balancing_process"></a>8.4.2. Inserting a new node and the balancing process</h4>
<div class="paragraph">
<p>Figure 8.32 presents the red-black tree construction algorithm in its most general form</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_32_Insert.jpg" alt="Fig8 32 Insert" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.32. DRAKON-diagram of the function <code>Insert(tree, data)</code></p>
</div>
<div class="paragraph">
<p>Next, consider the node positions in the tree as a result of each new
node insertion and determine which properties of the red-black tree are
violated. To understand this process, we introduce the following
notation: x - new node, P (Parent) - parent of node x, G (Grandparent) -
ancestor (parent of parent), U (Uncle) - uncle of node x, S - siblings (Figure 8.33).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_33_family.jpg" alt="Fig8 33 family" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.33. Designation of the degree of "kinship" of RB Tree nodes (x, P, G, U, S)</p>
</div>
<div class="paragraph">
<p>To describe the process of balancing the red-black tree, enter the term cluster tree (tree-cluster) - a set of nodes involved in balancing.</p>
</div>
<div class="paragraph">
<p>To describe the process of balancing the red-black tree, let’s name the set of nodes involved in balancing <em>tree-cluster</em> and enter a local syntax:
<strong>:R or :B</strong> is the color of the node. For example, P:R is the red parent.
<strong>&#8656; or &#8658;</strong> - the direction of the node position. For example, x &#8656; P - the new node x is located to the left of the parent node P.
The different instances of the red and black nodes are shown in the table
When a new element is inserted, it is assigned a red colour. To satisfy
the first two rules, it is sufficient to simply repaint the new vertices
in the desired colour. After each insertion, all these properties of the
red-black tree must be checked. If at least one property is not
satisfactory, the rotation and colour change operations are performed (Table ).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Variant</th>
<th class="tableblock halign-left valign-top">nodeImage</th>
<th class="tableblock halign-left valign-top">Violation</th>
<th class="tableblock halign-left valign-top">Fix strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red Uncle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R,x&#8656;P; P:R,P&#8656;G; G:B; U:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both x and P are red; G has two red children (P and U).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recolor P and U to black (P:B, U:B), G to red (G:R); set x = G (propagate upward).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black Uncle Case 1 (L–L)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R,x&#8656;P; P:R,P&#8656;G; G:B; U:B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x and P are both red and lie on left-left; uncle is black.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recolor P to black (P:B) and G to red (G:R); Right-rotate about (G).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black Uncle Case 2 (R–R)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R,x&#8658;P; P:R,P&#8658;G; G:B; U:B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x and P are both red and lie on right-right; uncle is black.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recolor P to black (P:B) and G to red (G:R); Left-rotate about (G).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black Uncle Case 3 (L–R)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R,x&#8658;P; P:R,P&#8656;G; G:B; U:B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">both x and P are red; x is right child of P, P is left child of G; uncle is black;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Left-rotate about (P), then treat as (L–L).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black Uncle Case 4 s(R–L)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R,x&#8656;P; P:R,P&#8658;G; G:B; U:B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x is left child of P, P is right child of G; both x and P are red; uncle is black;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Right-rotate about (P), then treat as (R–R).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The DRAKON-diagram of the red-black tree balancing algorithm when entering a new node is shown in Figure 8.34,8.35.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_34_fixRedRed.svg" alt="Fig8 34 fixRedRed" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.35. Red-Black Tree Balancing Algorithm DRAKON-diagram</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_35_diagr_figs.svg" alt="Fig8 35 diagr figs" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.35. Illustration of Red-Black Tree Balancing Algorithms</p>
</div>
<div class="paragraph">
<p>The dragon diagram of the node rotation algorithms to the red and black tree cluster is shown in Figure 8.36a,b.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_36a_rotateLeft.png" alt="Fig8 36a rotateLeft" width="75%">
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_36b_rotateRight.png" alt="Fig8 36b rotateRight" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.36. DRAKON-diagrams of the red-black tree cluster node rotation algorithm
a) Left-rotation; b) Right-rotation</p>
</div>
<div class="paragraph">
<p>The visualization of the red-black tree balancing process during the construction from a tuple of input node keys [11, 12, 13, 14, 15, 16, 17, 18, 19] is shown in Figure 8.37:</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_37_rbProcess.jpg" alt="Fig8 37 rbProcess" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.37. Process for Balancing the Red-Black Tree</p>
</div>
</div>
<div class="sect3">
<h4 id="_8_4_3_deleting_a_node_from_a_red_black_tree"><a class="anchor" href="#_8_4_3_deleting_a_node_from_a_red_black_tree"></a>8.4.3. Deleting a Node from a red-black tree</h4>
<div class="paragraph">
<p>Removing a node from a RB tree is a complex process because
it depends on the location of the node, the presence of children, and
the colour of the nodes. It is important to remember that all
transformations of the tree structure must maintain its properties. The
DRAKON-diagram of the node removal algorithm is shown in Figures 8.38a,b. This
algorithm can be divided into three stages.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_38a_mindMap_deleteNode.jpg" alt="Fig8 38a mindMap deleteNode" width="75%">
</div>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_38b_deleteNode.jpg" alt="Fig8 38b deleteNode" width="75%">
</div>
</div>
<div class="paragraph text-center">
<p>Figure 8.38. Node Deletion Algorithm (a -intellect map; b - DRAKON-diagram)</p>
</div>
<div class="paragraph">
<p><strong>The first step</strong> is to delete the node. The algorithm traverses the
nodes of the red-black tree, moving left or right, depending on whether
the key of the current node is larger or smaller than the specified
value. When a node with the key key is found, it is stored in the
variable z. The specified node is then removed from its original
location in the tree.</p>
</div>
<div class="paragraph">
<p><strong>The second step is to fix the double black node.</strong> If the node to be
removed was black, it may disturb the properties of the red-black tree,
since all paths from the root to the leaves must contain the same number
of black nodes. To remedy this, the concept of a "double black" node is
introduced. If the node x <em>that replaced the deleted node is black, it
becomes a "double black" node.</em></p>
</div>
<div class="paragraph">
<p><strong>The third stage is the correction of the double black nodes.</strong> To fix the
"double black" node, thefunctions <em>fixDoubleBlack (tree, x)</em> and <em>fixDoubleBlackStep(tree, x)</em> are called (Figures 8.39a,b). This feature fixes the "double black nodes" by using a series of rotations and recoloring steps. It considers several cases, depending on the colour of the brother of the "double black" node and its descendants. The function  <em>fixDoubleBlackStep (tree, x)</em> handles all of these cases to ensure that the red-black tree remains balanced after each deletion operation (Table ).</p>
</div>
<div class="paragraph">
<p>Figure 8.39. DRAKON-diagram of the algorithm for correcting the structure of a red-black tree cluster in the “double-black” case</p>
</div>
<div class="paragraph">
<p><strong>New Table with nodeImage</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">nodeImage</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Required Actions</th>
<th class="tableblock halign-left valign-top">fixDoubleBlack?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red leaf node (no children)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove directly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x_l:R or x_r:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black node with one red child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promote child, recolor to black</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x_l:B or NIL; x_r:B or NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black node with only black or null children</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double-black arises; call fixDoubleBlack(x)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x_l:#; x_r:#; y = min(x_r); y_l:NIL; y_r:NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two children; successor is direct child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replace x with y; transplant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x_l:#; x_r:#; y = min(x_r); y_r ≠ NIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two children; successor has a right child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replace x with y; transplant and reconnect y_r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Before joinParentChild</th>
<th class="tableblock halign-left valign-top">After joinParentChild</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">image::_images/before_join.png[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">image::_images/after_join.png[]</p></td>
</tr>
</tbody>
</table>
<div class="imageblock text-center unresolved">
<div class="content">
<img src="_images/Fig8_joinPC.png" alt="Fig8 joinPC" width="80%">
</div>
<div class="title">Figure 8.XFigure 8.X — Replacing a node in a red-black tree using <code>joinParentChild</code></div>
</div>
<div class="paragraph text-center">
<p>The top diagram illustrates the replacement of node U (<code>9</code>) with subtree V (<code>7</code>) before calling <code>joinParentChild(tree, U, V)</code>.
The bottom diagram shows the result of the operation: node <code>7</code> has taken the place of <code>9</code>, preserving the tree&#8217;s structure and balance.</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_41 b_deleteNode.jpg" alt="Fig8 41 b deleteNode" width="75%">
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Violation analysis</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Red-Black Property Violated</th>
<th class="tableblock halign-left valign-top">Required Fix</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No fix needed</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Consider in more detail the different instances of the removal node in
the structure of the red-black tree. In the first step, the node is
removed simply as a node in the binary search tree. If the replacement
node is a "red" node, or if the removed node is a "red" node, the
removed node is replaced by another node. There is no need to make any
further changes to the tree structure (Figure 8.37).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="_images/Fig8_38b_deleteNode.jpg" alt="Fig8 38b deleteNode" width="75%">
</div>
</div>
<div class="paragraph">
<p>Figure 3.37. Deletion of red node (20)</p>
</div>
<div class="paragraph">
<p>If the node to be deleted and the node that replaces it are black nodes,
a situation called a "double black node" occurs. In this case, some
additional operations must be performed to ensure that the properties of
the red-black wood are preserved. The drakon- diagram algorithm of this
process is shown in Fig. 8.38.</p>
</div>
<div class="paragraph">
<p>If the replacement node is a leaf node (i.e., has no child nodes), we
replace the node with a "zero" leaf node and colour it black. If the
replacement node has one child node, we replace the node with its child
node and colour it black. If the replacement node has two child nodes, we
replace the node with its subsequent node in order, and then delete the
next node in order (which is no more than a node with one child node)
using the method described above.</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image41.jpg" alt="media/image41" width="1049" height="375"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.38. DRAKON-diagram of the node structure correction algorithm
when removing "double black node"</p>
</div>
<div class="paragraph">
<p>If a node is deleted and replaced with another node, the properties of
the red-black wood may be compromised. To restore them, the following
operations must be performed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the node to be deleted is red, the properties of the red-black tree
are not disturbed. If the replacement node is red, it should be
repainted black.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>2. Next, rotate, recolour the nodes and/or transfer the
"blackness" (the number of black nodes relative to the red ones) up the
tree until the tree is balanced.</p>
</div>
<div class="paragraph">
<p>3. At the same time, you need to make sure that the root of the
tree is black.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider options for restoring the properties of red-black wood.
Enter the following notations: the node to be deleted is "x", the child
node of the deleted node is "y", and the sibling of the node to be
deleted is "s" (Figure 8.39).</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image42.jpg" alt="media/image42" width="280" height="174"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.39. Tree node relationship</p>
</div>
<div class="paragraph">
<p>Option 1: If the child element (y) of the node to be deleted (x) is
coloured red, then after deletion it should be recoloured black, as a
result of which the number of black nodes will be restored (Figure
8.40).</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image43.jpg" alt="media/image43" width="332" height="144"></span></p>
</div>
<div class="paragraph">
<p>Fig. 8.40. Deleting and repainting the child of the node to be removed
(y)</p>
</div>
<div class="paragraph">
<p>Option 2: When the sib(s) of the node to be deleted (x) is coloured
black, and at least one of the descendants is red, then four different
combinations are possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Option 2(a): The brother(s) of the node to be deleted (x) is black. In
this case, the brother (s) is the left descendant of the parent (P), and
the left child of the brother is coloured red. This is the so-called
"left-left <em>configuration"</em>, in which the balance is achieved by the
right rotation, after which the colour of the child should be replaced by
black (Fig. 8.41).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image44.jpg" alt="media/image44" width="427" height="165"></span></p>
</div>
<div class="paragraph">
<p>Figure. 8.41. Left-Left node delete configuration</p>
</div>
<div class="paragraph">
<p>Option 2(b): Mirror image of case 2(a). The "s" brother is his parent&#8217;s
right child, and his right child is the red child. The right-right
configuration performs a left-hand rotation. The child node is then
changed to black. As a result, the black node counter property is
restored (Fig. 8.42).</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image45.jpg" alt="media/image45" width="412" height="123"></span></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Figure 8.42. Right-Right configuration of node deletion</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Option 2 (c). The brother (s) of the remote node (y) is black. The
brother(s) is the left offspring of his parent, and his right child is
red. This is a left-to-right configuration, so a left rotation is
performed followed by a right rotation. The child node is coloured black
(Figure 8.43):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image46.jpg" alt="media/image46" width="670" height="121"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.43. Left-Right node delete configuration</p>
</div>
<div class="paragraph">
<p>Option 2(d): The brother (s) of the remote node (y) is coloured black.
The brother (s) is the right child of his parent (P) and his left child
is the red child. A right-left rotation is then performed, followed by a
left-hand rotation. The colour of the child node changes to black (Fig.
8.44).<span class="image unresolved"><img src="media/image47.jpg" alt="media/image47" width="670" height="121"></span> Figure
8.44. Right-Left node delete configuration</p>
</div>
<div class="paragraph">
<p>Option H: If the node (y) to be removed and its brother(s) are coloured
black and both of its descendants are missing, i.e. black by definition,
then you need to recolour the children red and recursively add black to
the parent. If the parent was red, then it became black. If the parent
was black, it would become double black. If the parent is the root, then
it remains black. For example, below is a case where the node (y) to be
deleted and its brother (s) are black (Figure 8.45):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image48.png" alt="media/image48" width="477" height="176"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.45 The Process of rebuilding a tree with two black nodes (y)
and (s)</p>
</div>
<div class="paragraph">
<p>Option 4: If the sib(s) of the node to be removed (y) is coloured red,
then a rotation is performed to achieve the balance of the tree. The
sister nodes are then repainted. For example, consider the following
option (Fig. 8.46):</p>
</div>
<div class="paragraph">
<p><span class="image unresolved"><img src="media/image49.jpg" alt="media/image49" width="670" height="169"></span></p>
</div>
<div class="paragraph">
<p>Figure 8.46. The process of rebuilding a tree with two nodes (y) and (s)
of different colours</p>
</div>
<div class="paragraph">
<p>Conclusion</p>
</div>
<div class="paragraph">
<p>Trees are one of the most important data structures in computer science,
used to represent hierarchical relationships and organize data. They
provide efficient search, insert, and delete operations, making them
ideal for use in a variety of applications.</p>
</div>
<div class="paragraph">
<p>AVL trees, named after their creators Adelsky-Velsky and Landis, are
balanced binary search trees. They provide fast search, insertion, and
deletion by keeping the height of the tree logarithmic relative to the
number of nodes. However, AVL trees require additional insertion and
deletion operations to maintain balance, which can be a disadvantage in
some applications.</p>
</div>
<div class="paragraph">
<p>Red-black trees are another type of balanced binary search trees. They
provide efficient search, insert, and delete operations, but can be more
difficult to implement because of the additional properties they must
support. They are widely used in many standard libraries.</p>
</div>
<div class="paragraph">
<p>The choice of a specific tree type depends on the specific requirements
of the application. AVL trees are generally preferred when frequent
searches are the most important operations, as they provide a more
stringent balance than red-black trees. On the other hand, red-and-black
trees can be more effective with frequent insertions and removals, as
they require fewer turns to maintain balance.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to remember that both types of trees require additional
memory to store balance information, and both can be difficult to
implement. In some cases, other data structures, such as hash tables or
B-trees, may be more appropriate. However, despite these challenges,
trees continue to play a central role in computer science and are a key
tool for any programmer.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 99%;">
<colgroup>
<col style="width: 28%;">
<col style="width: 5%;">
<col style="width: 8%;">
<col style="width: 12%;">
<col style="width: 6%;">
<col style="width: 8%;">
<col style="width: 8%;">
<col style="width: 8%;">
<col style="width: 9%;">
<col style="width: 8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">Tree type</th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">AVL</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Red-Black</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time Complexity:</p>
</div>
<div class="paragraph">
<p>Insert, Find, Delete</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(sqrt(N))</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(logN)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Space Complexity</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Iterative</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Recursive</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(N)</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(1)</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">O(H)=O(sqrt(N))</p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">nodeImage</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Required Actions</th>
<th class="tableblock halign-left valign-top">fixDoubleBlack?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red leaf node (no children)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove directly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x.left or x.right = R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black node with one red child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Promote child, recolor to black</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x.left and x.right = B or null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Black node with black or null child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double-black arises</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixDoubleBlack(x)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x has 2 children; y = max(x.right); y.child = null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two children, successor is direct child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replace x with y, transplant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B; x has 2 children; y = min(x.right); y.child ≠ null</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two children, successor has a child</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replace x with y; transplant + reconnect y&#8217;s child</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 11.1112%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Case</th>
<th class="tableblock halign-left valign-top">Node</th>
<th class="tableblock halign-left valign-top">Violation Conditions</th>
<th class="tableblock halign-left valign-top">Cluster Transformation</th>
<th class="tableblock halign-left valign-top">Fix Strategy</th>
<th class="tableblock halign-left valign-top">Black Height Loss?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:R, x is a leaf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F{x:R} = {∅}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove directly</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B, x is a leaf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F{x:B, C=∅} = {∅, black height loss at P}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fixBlackHeight(P)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B, C=red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F{x:B, C:R} = {C&#8658;x:B}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replace x with C and repaint black</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B, C:B, S:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F{&#8230;&#8203;} = {&#8230;&#8203;}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recolor &amp; rotate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x:B, S:B, S_l:R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes
&#8230;&#8203;</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
